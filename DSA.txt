1.)       ( Diagonal matrix using constructor and destructor )

#include <iostream>
using namespace std;

class Diagonal
{
    private:
        int *A;
        int n;
    public:
        Diagonal(int n)
        {
            this->n=n;
            A = new int[n];
        }
        ~Diagonal()
        {
            delete []A;
        }
        void Set(int i,int j,int x);
        int  Get(int i,int j);
        void Display();
};
void Diagonal::Set(int i,int j,int x)
{
    if(i==j)
    A[i-1] = x;
}
int Diagonal::Get(int i,int j)
{
    if(i==j)
    return A[i-1];
    else
    return 0;
}
void Diagonal::Display()
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(i==j)
            cout<<A[i-1]<<" ";
            else
            cout<<"0 ";
        }
        cout<<endl;
    }
}

int main()
{
    int a,b;
    cout<<"Enter Dimensions"<<endl;
    cin>>a;
    Diagonal dm(a);
    cout<<"Enter all element"<<endl;
    for(int i=1;i<=a;i++)
    {
        for(int j=1;j<=a;j++)
        {
            cin>>b;
            dm.Set(i,j,b);
        }
    }
    cout<<"Diagonal is "<<endl;
    dm.Display();
    
    return 0;
}
-----------------------------------------------------------------------
2.)      (  Lower Triangle matrix program  )

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

struct matrix 
{
    int *A;
    int n;
};

void Set(struct matrix *m,int i,int j,int x)
{
    if(i>=j) 
    m->A[i*(i-1)/2+j-1]=x ;
}
int Get(struct matrix m,int i,int j)
{
    if(i>=j)
    return m.A[i*(i-1)/2+j-1];
    else
    return 0;
}
void Display(struct matrix m)
{
    for(int i=1;i<=m.n;i++)
    {
        for(int j=1;j<=m.n;j++)
        {
            if(i>=j)
           // cout<<m.A[m.n*(j-1)+(j-2)*(j-1)/2+i-j]<<" ";
            cout<<m.A[i*(i-1)/2+j-1]<<" ";
            else
            cout<<"0 ";
        }
        cout<<endl;
    }
}

int main()
{
    struct matrix m;
    cout<<"Enter Dimension "<<endl;
    cin>>m.n;
    m.A = new int[m.n];
    cout<<endl<<"Enter all element"<<endl;
    int e;
    for(int i=1;i<=m.n;i++)
    {
        for(int j=1;j<=m.n;j++)
        {
            cin>>e;
            Set(&m,i,j,e);
        }
    }
    cout<<endl<<"Elements are :- "<<endl;
    Display(m);
    delete []m.A;
    
    return 0;
}
-----------------------------------------------------------------------
3.)      ( Upper Triangle matrix )

#include <iostream>
using namespace std;

struct matrix
{
  int *A;
  int n;
};

void Set(struct matrix *m,int i,int j,int x)
{
    if(i<=j)
    m->A[j*(j-1)/2 + i-1]=x;
}
int Get(struct matrix m,int i,int j)
{
    if(i<=j)
    return m.A[j*(j-1)/2 + i-1];
    return 0;
}
void Display(struct matrix m)
{
    for(int i=1;i<=m.n;i++)
    {
        for(int j=1;j<=m.n;j++)
        {
            if(i<=j)
            cout<<m.A[j*(j-1)/2 + i-1]<<" ";
            else 
            cout<<"0 ";
        }
        cout<<endl;
    }
}

int main()
{
    struct matrix m;
    cout<<"Enter Dimensions"<<endl;
    cin>>m.n;
    m.A = new int[m.n];
    cout<<endl<<"Enter all elements"<<endl;
    int s;
    for(int i=1;i<=m.n;i++)
    {
        for(int j=1;j<=m.n;j++)
        {
        cin>>s;
        Set(&m,i,j,s);
        }
    }
    cout<<endl;
    Display(m);
    delete []m.A;
    
    return 0;
}
----------------------------------------------------------------------
4.)      ( Symmetry matrix )

            A.)      <  Without input  >

#include <iostream>
using namespace std;

const int MAX = 100;

bool isSymmetric(int mat[][MAX], int N)
{
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
			if (mat[i][j] != mat[j][i])
				return false;
	return true;
}

int main()
{
	int mat[][MAX] = { { 1, 3, 5 },
					{ 3, 2, 4 },
					{ 5, 4, 1 } };

	if (isSymmetric(mat, 3))
		cout << "Yes";
	else
		cout << "No";
	return 0;
}
------------------
              B.)       <  In input  >

#include <iostream>
using namespace std;

int main()
{
    //variables used
    int r,c,i,j,flag=0;

    //taking input for number of rows and columns
    cout<<"Enter number of rows and columns :"<<endl;
    cin>>r>>c;

    //array of user dimensions
    int arr[r][c];

    //checking if the matrix is square
    if(r!=c)
        cout<<"\nNot a symmetric matrix";
    else
    {
        //taking input for values of the matrix
        cout<<"\nEnter the values in the matrix :"<<endl;
        for(i=0 ; i<r ; i++)
        {
            for(j=0 ; j<c ; j++)
            {
                cin>>arr[i][j];
            }
        }

        //printing the user entered matrix
        cout<<"The entered matrix is :";
        for(i=0 ; i<r ; i++)
        {
            for(j=0 ; j<c ; j++)
            {
                cout<<arr[i][j]<<" ";
            }
            cout<<endl;
        }

        //checking for symmetry
        for(i=0 ; i<r ; i++)
        {
            for(j=0 ; j<c ; j++)
            {
                if (arr[i][j] != arr[j][i])
                {
                    flag=0;
                    break;
                }
            }
        }

        //displaying the result
        if(flag == 0)
            cout<<"\nIt's a symmetric matrix";
        else
            cout<<"\nNot a symmetric matrix";
    }
    return 0;
}
----------------------------------------------------------------------
5.)      ( Tri - Diagonal Matrix Program in c++  )

Note :- < i,j == 1 , then error occer .>

#include <iostream>
using namespace std;

struct matrix 
{
    int *A;
    int n;
};

void Set(struct matrix *m,int i,int j,int t)
{
    if(i - j == 1)
    {
    m->A[i -  1] = t;
    }
    if(i - j == 0)
    {
    m->A[m->n - 1 + i - 1] = t;
    }
    if(i - j == -1)
    {
    m->A[(2*m->n) - 1 + i - 1] = t;
    }
}

int Get(struct matrix m,int i,int j)
{
    if(i - j == 1)
    {
    return m.A[i - 1];
    }
    if(i - j == 0)
    {
    return m.A[m.n - 1 + i - 1];
    }
    if(i - j == - 1)
    {
    return m.A[(2 * m.n) - 1 + i - 1]; 
    }
    return 0;
}

void Display(struct matrix m)
{
    for(int i=1;i<=m.n;i++)
    {
        for(int j=1;j<=m.n;j++)
        {
            if(i - j == 1)
            {
            cout<<m.A[i - 1]<<" ";
            }
            else if(i - j == 0)
            {
            cout<<m.A[m.n - 1 + i - 1]<<" ";
            }
            else if(i - j == - 1)
            {
            cout<<m.A[(2 * m.n) - 1 - i - 1]<<" ";
            }
            else
            {
            cout<<"0 ";
            }
        }
        cout<<endl;
    }
}

int main()
{
    int t;
    struct matrix m;
    cout<<"Enter length of matrix "<<endl;
    cin>>m.n;
    m.A = new int[m.n];
    cout<<endl<<"Enter dimensions of matrix"<<endl;
    for(int i=1;i<=m.n;i++)
    {
        for(int j=1;j<=m.n;j++)
        {
            cin>>t;
            Set(&m,i,j,t);
        }
    }
    cout<<endl;
    Display(m);
    delete []m.A;
    
    return 0;
}
---------------------------------------------------------
6.)     ( Teoplitz matrix program in c++ )


#include <iostream>
using namespace std;
#define N 4
#define M 5

bool isDiagonal(int mat[N][M],int i,int j)
{
    int res = mat[i][j];
    while(++i < N && ++j < M)
    {
        if(mat[i][j] != res)
        return false;
    }
    return true;
}

bool isToeplitz(int mat[N][M])
{
    for(int i=0;i<N;i++)
    {
        if(!isDiagonal(mat,0,i))
        return false;
    }
    for(int j=0;j<M;j++)
    {
        if(!isDiagonal(mat,j,0))
        return false;
    }
    return true;
}

int main()
{
    int mat[N][M] = { {1,2,3,4,5},
                      {3,1,2,3,4},
                      {4,3,1,2,3},
                      {5,4,3,1,2}
    };
    if(isToeplitz(mat))
    {
    cout<<"It is a Toeplitz ";
    }
    else
    cout<<"It is not a Toeplitz";
    
    
    return 0;
}

---------------------------------------------------------
                         Matrix  End
---------------------------------------------------------
1.)     ( Create Sparse Martix in c++ )

#include <iostream>
using namespace std;
#define MAX 100

int data[MAX][3];
int len = 0;

void insert(int r,int c,int val)
{
   data[len][0] = r;
   data[len][1] = c;
   data[len][2] = val;
   len++;
}

void Print(int r,int c)
{
    cout << "\nDimension of Sparse Matrix: "<< len << " x " << 3;
    cout << "\nSparse Matrix: \nRow Column Value\n";
    cout<<"    "<<r<<"    "<<c<<"    "<<len<<endl;
    for(int i=0;i<len;i++)
    {
        cout<<"    "<<data[i][0]<<"   "<<data[i][1]<<"   "<<data[i][2]<<" \n ";
    }
}

int main()
{
    int r,c;
    cout<<"Enter Row and columns of matrix"<<endl;
    cin>>r>>c;
    int mat[r][c];
    cout<<"Enter Elements of the matrix"<<endl;
    for(int i=0;i<r;i++)
    {
        for(int j=0;j<c;j++)
        {
            cin>>mat[i][j];
            if(mat[i][j]>0)
            insert(i,j,mat[i][j]);
        }
    }
    cout<<endl;
    Print(r,c);
    
    return 0;
}
------------------------------------------------------------
2.)    ( Adding two Sparse matrix in c++ )

#include <iostream>
using namespace std;

class sparse_matrix 
{
    const static int MAX = 20;
    int **data;
    int row, col;
    int len;
    
    public:
    
        sparse_matrix(int r,int c)
    {
        row = r;
        col = c;
        len = 0;
        data = new int *[MAX];
        for(int i =0; i < MAX; i++)
        data[i] = new int [3];
    }
    
    void insert(int r,int c,int val)
    {
        if(r > row ||  c > col)
        {
            cout<< "Wrong entry";
        }
        else
        {
            data[len][0] = r;
            data[len][1] = c;
            data[len][2] = val;
            len++;
        }
    }
    
    void add(sparse_matrix b)
    {
        if(row != b.row || col != b.col)
            cout<<"Matrices can' be added";
        else
        {
            int apos = 0 , bpos = 0;
            sparse_matrix result(row,col);
            while (apos<len && bpos<b.len)
            {
                if(data[apos][0]>b.data[bpos][0] || (data[apos][0] == b.data[bpos][0] && data[apos][1] > b.data[bpos][1]))
                {
                    result.insert(b.data[bpos][0],b.data[bpos][1],b.data[bpos][2]);
                    bpos++;
                }
                else if(data[apos][0]<b.data[bpos][0] || (data[apos][0] == b.data[bpos][0] && data[apos][1] < b.data[bpos][1]))
                    { 
                        result.insert(data[apos][0],data[apos][1],data[apos][2]);
                        apos++;
                    }
                else
                {
                    int addval = data[apos][2] + b.data[bpos][2];
                    if(addval != 0)
                    result.insert(data[apos][0],data[bpos][1],addval);
                    apos++;
                    bpos++;
                }
            }
            while(apos < len)
                result.insert(data[apos][0],data[apos][1],data[apos++][2]);
            while(bpos < b.len)
                result.insert(b.data[bpos][0],b.data[bpos][1],b.data[bpos++][2]);
            result.print();
        }
    }
    
    void print()
    {
        cout<<"\n Dimensions: "<<row<<" X "<<col;
        cout<<"\n Sparse matrix: \nRow\tcol\tvalue\n";
        
        for(int i=0; i<len; i++)
        {
            cout<<data[i][0]<<"\t"<<data[i][1]<<"\t"<<data[i][2]<<endl;
        }
    }
    
    ~ sparse_matrix()
    {
        delete []data;
    }
};

int main()
{
    sparse_matrix a(4,4);
    sparse_matrix b(4,4);
    
    a.insert(1,2,10);
    a.insert(1,4,12);
    a.insert(3,3,5);
    a.insert(4,1,15);
    a.insert(4,2,12);
    
    b.insert(1,3,8);
    b.insert(2,4,23);
    b.insert(3,3,9);
    b.insert(4,1,20);
    b.insert(4,2,25);
    
    cout<<" Addition: "<<endl;
    a.add(b);

    return 0;
}
----------------------------------->>>>>>>>>
            ( Second Method is :- Adding )

#include <iostream>
using namespace std;
class Element
{
public:
 int i;
 int j;
 int x;
};
class Sparse
{
private:
 int m;
 int n;
 int num;
 Element *ele;
public:
 Sparse(int m,int n,int num)
 {
 this->m=m;
 this->n=n;
 this->num=num;
 ele=new Element[this->num];
 }
 ~Sparse()
 {
 delete [] ele;
 }

 Sparse operator+(Sparse &s);

 friend istream & operator>>(istream &is,Sparse &s);
 friend ostream & operator<<(ostream &os,Sparse &s);


};

Sparse Sparse::operator+(Sparse &s)
{
 int i,j,k;
 if(m!=s.m || n!=s.n)
 return Sparse(0,0,0);
 Sparse *sum=new Sparse(m,n,num+s.num);

 i=j=k=0;
 while(i<num && j<s.num)
 {
 if(ele[i].i<s.ele[j].i)
 sum->ele[k++]=ele[i++];
 else if(ele[i].i > s.ele[j].i)
 sum->ele[k++]=s.ele[j++];
 else
 {
 if(ele[i].j<s.ele[j].j)
 sum->ele[k++]=ele[i++];
 else if(ele[i].j > s.ele[j].j)
 sum->ele[k++]=s.ele[j++];
 else
 {
 sum->ele[k]=ele[i];
 sum->ele[k++].x=ele[i++].x+s.ele[j++].x;
 }
 }
 }
 for(;i<num;i++)sum->ele[k++]=ele[i];
 for(;j<s.num;j++)sum->ele[k++]=s.ele[j];
 sum->num=k;

 return *sum;

}
 istream & operator>>(istream &is,Sparse &s)
 {
 cout<<"Enter non-zero elements";
 for(int i=0;i<s.num;i++)
 cin>>s.ele[i].i>>s.ele[i].j>>s.ele[i].x;
 return is;
 }
 ostream & operator<<(ostream &os,Sparse &s)
 {
 int k=0;
 for(int i=0;i<s.m;i++)
 {
 for(int j=0;j<s.n;j++)
 {
 if(s.ele[k].i==i && s.ele[k].j==j)
 cout<<s.ele[k++].x<<" ";
 else
 cout<<"0 ";
 }
 cout<<endl;
 }
 return os;
 }

int main()
{
 Sparse s1(5,5,5);
 Sparse s2(5,5,5);

 cin>>s1;
 cin>>s2;

 Sparse sum=s1+s2;

 cout<<"First Matrix"<<endl<<s1;
 cout<<"Second MAtrix"<<endl<<s2;
 cout<<"Sum Matrix"<<endl<<sum;

 return 0;
}

------------------------------------------------------------
3.)      ( Addition of two polynomial in c++ program )

#include <iostream>
using namespace std;
#define MAX 30

struct Term
{
    int coeff;
    int exp;
};

struct poly
{
    int n;
    struct Term *terms;
};

void create(struct poly *p)
{
    cout<<"Number of terms";
    cin>>p->n;
    p->terms = new Term[p->n]; //term = struct of term..
    cout<<"Enter terms in coeff and exp \n";
    for(int i=0;i<p->n;i++)
    cin>>p->terms[i].coeff>>p->terms[i].exp;
}

void display(struct poly p)
{
    for(int i=0;i<p.n;i++)
    cout<<p.terms[i].coeff<<"X"<<p.terms[i].exp<<endl;
}

struct poly *add(struct poly *p1,struct poly *p2)
{
    struct poly *sum;
    sum = new poly[MAX];
    sum->terms = new Term[p1->n + p2->n];
    
    int i=0,j=0,k=0;
    while(i<p1->n && j<p2->n)
    {
        if(p1->terms[i].exp > p2->terms[i].exp)
        sum->terms[k++] = p1->terms[i++];
        else if(p1->terms[i].exp < p2->terms[i].exp)
        sum->terms[k++] = p2->terms[j++];
        else
        {
         sum->terms[k].exp = p1->terms[i].exp;
         sum->terms[k++].coeff = p1->terms[i++].coeff + p2->terms[j++].coeff;
        }
    }
    for(;i<p1->n;i++) sum->terms[k++] = p1->terms[i];
    for(;j<p2->n;j++) sum->terms[k++] = p2->terms[j];
        
    sum->n=k;
    return sum;
};

int main()
{
    struct poly p1,p2,*p3;
    create(&p1);
    create(&p2);
    
    p3 = add(&p1,&p2);
    
    cout<<endl;
    display(p1);
    cout<<endl;
    display(p2);
    cout<<endl;
    display(*p3);
    
    return 0;
}
----------------------------------------------------------------
4.)      ( Creating Node and link-list in c++ )

class Node{
    
public:
    int data;
    Node* next;
    
};
 
int main() {
 
    int A[] = {3, 5, 7, 10, 15};
    
    Node* head = new Node;
    
    Node* temp;
    Node* last;
    
    head->data = A[0];
    head->next = nullptr;
    last = head;
 
    for (int i=1; i<sizeof(A)/sizeof(A[0]); i++){
 
        temp = new Node;
        temp->data = A[i];
        temp->next = nullptr;
        last->next = temp;
        last = temp;
    }
    
    Node* p = head;
 
    while (p != nullptr){
        cout << p->data << " -> " << flush;
        p = p->next;
    }
 
    return 0;
}

----------------->>
( Another Way in using struct. and using recurion ,Reverse print also)
(insert,searching,delete) 

#include <iostream>
using namespace std;

struct Node
{
    int data;
    struct Node *next;
}*head = NULL;

void create(int A[],int n)
{
    struct Node *last,*temp;
    head = new Node;
    head->data = A[0];
    head->next = NULL;
    last = head;
    
    for(int i=1;i<n;i++)
    {
        temp = new Node;
        temp->data = A[i];
        temp->next = NULL;
        last->next = temp;
        last = temp;
    }
}
// adding the Node.
int Add(struct Node *a)
{
    int n=0;
    while(a != 0)
    {
        n = n + a->data;
        a = a->next;
    }
    return n;
}

void Display(struct Node *p)
{
    if(p)
    {
    cout<<p->data<<" ";
    Display(p->next);
    }
}

void RDisplay(struct Node *n)
{
    if(n)
    {
        RDisplay(n->next);
        cout<<n->data<<" ";
    }
}

// Searching in iterative
bool Search(struct Node *n,int key)
{
    while(n != 0)
    {
        if(key == n->data)
        {
        return true;
        }
        n = n->next;
    }
    return false;
}
// Searching in Recursive
/*
bool Search(struct Node *n,int key)
{
    if(n==NULL)
    return false;
    else if(key == n->data)
    return true;
    return Search(n->next,key);
}

// insert Node at last;

void insert(struct Node *p,int val)
{
    while(p->next != NULL)
    {
        p=p->next;
    }
    struct Node *n = new Node;
    n->data = val;
    n->next = NULL;
    p->next = n;
    p = n;
}
*/


// delete linked list at last..

void Ldelete(struct Node *p)
{
    struct Node *q = NULL;
    while(p!=NULL)
    {
        q = p;
        p->next;
        delete q;
    }
}


int main()
{
    int A[] = {1,2,3,4,5};
    int n = sizeof(A)/sizeof(A[0]);
    create(A,n);
    Display(head);
    cout<<endl;
    RDisplay(head);
    //Searching in linked list.
    if(Search(head,1))
    cout<<"Present";
    else
    cout<<"Not found";
    
    Ldelete(head);
    return 0;
}

--------------------------------------------------------------
5.)       ( Concatenating of Two Linked List )

#include <iostream>
using namespace std;

struct Node
{
    int data;
    struct Node *next;
}*first = NULL,*second = NULL;

void create(int A[],int n,Node *p)
{
    struct Node *temp;
    for(int i=1; i<n; i++)
    {
        temp = new Node;
        temp->data = A[i];
        temp->next = NULL;
        p->next = temp;
        p = temp;
    }
}

void Display(struct Node *p)
{
    if(p)
    {
        cout<<p->data<<" ";
        Display(p = p->next);
    }
}

void concatenate(struct Node *a,struct Node *b)
{
    if(a != NULL && b!= NULL)
    {
/*
        // Recusive Code
        if(a->next != NULL)
        concatenate(a->next,b);
        else
        a->next = b; 
*/
        // Iterative Code
        while(a->next)
        {
        a = a->next;
        }
        a->next = b;
    }
    else
    cout<<"Either a or b is NULL"<<endl;
}

int main()
{
    int A[] = {1,2,3,4,5};
    int B[] = {6,7,8,9,2};
    int n = sizeof(A)/sizeof(A[0]);
    int n1 = sizeof(B)/sizeof(B[0]);
    struct Node *last1,*last2;
    
    first = new Node;
    first->data = A[0];
    first->next = NULL;
    last1 = first;
    
    second = new Node;
    second->data = B[0];
    second->next = NULL;
    last2 = second;
    create(B,n1,last2);
    create(A,n,last1);
    
    cout<<"First Linked List :- "<<endl;
    Display(first);

    cout<<endl<<"Second Linked List :- "<<endl;
    Display(second);
    cout<<endl;
    concatenate(first,second);
    cout<<endl<<"Concatenated Linked List :- "<<endl;
    Display(first);
    
    return 0;
}
----------------------------------------------------------------------
6.)   < Merge two sorted Linked List >

#include <iostream>
using namespace std;

struct Node
{
    int data;
    struct Node *next;
    
}*first = NULL,*second = NULL,*third = NULL;

void Display(struct Node *p)
{
    while(p != NULL)
    {
        cout<<p->data<<" ";
        p = p->next;
    }
}

void create(int A[],int n)
{
    struct Node *temp,*last;
    first = new Node;
    first->data = A[0];
    first->next = NULL;
    last = first;
    for(int i=1;i<n;i++)
    {
        temp = new Node;
        temp->data = A[i];
        temp->next = NULL;
        last->next = temp;
        last = temp;
    }
}

void create2(int A[],int n)
{
    struct Node *temp,*last;
    second = new Node;
    second->data = A[0];
    second->next = NULL;
    last = second;
    for(int i=1;i<n;i++)
    {
        temp = new Node;
        temp->data = A[i];
        temp->next = NULL;
        last->next = temp;
        last = temp;
    }
}

void merge(struct Node *p,struct Node *q)
{
    struct Node *last;
    if(p->data < q->data)
    {
        third = last = p;
        p = p->next;
        last->next = NULL;
    }
    else
    {
        third = last = q;
        q = q->next;
        last->next = NULL;
    }
    while(p && q)
    {
        if(p->data < q->data)
        {
            last->next = p;
            last = p;
            p = p->next;
            last->next = NULL;
        }
        else
        {
            last->next = q;
            last = q;
            q = q->next;
            last->next = NULL;
        }
        
    }
    if(p)
    last->next = p;
    if(q)
    last->next = q;
}

int main()
{
    int A[] = {10,20,30,40};
    int B[] = {15,25,35,45};
    create(A,4);
    create2(B,4);
    merge(first,second);
    Display(third);
    
    return 0;
}
----------------------------------------------------------------------
7.)  < IsLoop or Linear in linked-list >

int isLoop(struct Node *f)
{
 struct Node *p,*q;
 p=q=f;
 
 do
 {
 p=p->next;
 q=q->next;
 q=q?q->next:q;
 }while(p && q && p!=q);
 
 if(p==q)
 return 1;
 else
 return 0;
}

-----------------------------------------------------------------------
8.)     < Delete in circular Linked list >

void Delete(int pos)
{
    struct Node *p,*q;
    int x;
    q=p=first;
    if(pos < 0 || pos > 5)
    {
        cout<<"\ninvalid position\n";
    }
    else{
    if(pos == 0)
    {
    do
    {
        p=p->next;
    }while(p->next != first);
    first=first->next;
    p->next = first;
    x=q->data;
    delete q;
    }
    else
    {
        for(int i=0;i<pos-1;i++){
        q=p;
        p=p->next;
        }
        q->next = p->next;
    x=p->data;
    delete p;
    }
    }
}
---------------
(B)     < Another code >

int Delete(struct Node *p,int index)
{
 struct Node *q;
 int i,x;
 
 if(index <0 || index >Length(Head))
 return -1;
 if(index==1)
 {
 while(p->next!=Head)p=p->next;
 x=Head->data;
 if(Head==p)
 {
 free(Head);
 Head=NULL;
 }
 else
 {
 p->next=Head->next;
 free(Head);
 Head=p->next;
 }
 }
 else
 {
 for(i=0;i<index-2;i++)
 p=p->next;
 q=p->next;
 p->next=q->next;
 x=q->data;
 free(q);
 }
 return x;
}

----------------------------------------------------------------------
9.)      < Doubly linked list all operation perform >
             ( Delete , Insert , Length , create , Reverse )

#include <iostream>
using namespace std;
// Structing Node
struct Node
{
    struct Node *prev;
    int data;
    struct Node *next;
    
}*first = NULL;
// Create Function of Doubly linked List
void Create(int A[],int n)
{
    struct Node *temp,*last;
    first = new Node;
    first->prev = NULL;
    first->data = A[0];
    first->next = NULL;
    last = first;
    
    for(int i=1;i<n;i++)
    {
        temp = new Node;
        temp->prev = last;
        temp->next = NULL;
        temp->data = A[i];
        last->next = temp;
        last = temp;
    }
}
// fining length by recursion
int Length(struct Node *p)
{
    if(p != NULL)
    return Length(p->next) + 1;
    return 0;
}
// Display Doubley linked List
void Display(struct Node *p)
{
    while(p != NULL)
    {
        cout<<p->data<<" ";
        p = p->next;
    }
}
//  Inserting in Doubly Linked List.
void insert(int val,int pos)
{
    struct Node *p,*A = new Node;
    p = first;
    if(val >= 0 || val <= Length(first))
    {
        if(pos == 0)
        {
            A->prev = NULL;
            A->next = first;
            first->prev = A;
            first = A;
        }
        else
        {
            for(int i=0;i<pos-1;i++)
            p = p->next;
            A->prev = p;
            A->next = p->next;
            p->next = A;
            p = p->next->next;
            p->prev = A;
        }
         A->data = val;
    }
    else 
    cout<<"\n Invalid Position \n";
}

int Delete(int pos)
{
    int A = 0;
    struct Node *r,*q,*p = first;
    int x = Length(first);
    if(pos >= 0 || pos <= Length(first))
    {
        if(pos == 0)
        {
            first = first->next;
            first->prev = NULL;
        }
        else if(pos == (x-1))
        {
            for(int i=0;i<pos;i++)
            {
                q = p;
                p = p->next;
            }
            q->next = NULL;
        }
        else
        {
            for(int i=0; i<pos; i++)
            {
                r = q = p;
                p = p->next;
            }
            r = p;
            r = r->next;
            q->next = r;
            r->prev = q;
        }
        A = p->data;
        delete p;
    }
    else 
    cout<<"\n Invalid Position \n";
    
    return 0;
}

void Reverse1(struct Node *p)
{
 int *A,i=0;
 struct Node *q=p;
 int n = Length(first);
 A = new int[n];

 while(q!=NULL)
 {
 A[i]=q->data;
 q=q->next;
 i++;
 }
 q=p;
 i--;
 while(q!=NULL)
 {
 q->data=A[i];
 q=q->next;
 i--;
 }
}

void Reverse2(struct Node *p)
{
 struct Node *q=NULL,*r=NULL;

 while(p!=NULL)
 {
 r=q;
 q=p;
 p=p->next;
 q->next=r;
 }
 first=q;
}

void Reverse3(struct Node *q,struct Node *p)
{
 if(p)
 {
 Reverse3(p,p->next);
 p->next=q;
 }
 else
 first=q;
}

int main()
{
    int A[] = {1,2,3,4,5,6};
    int n = sizeof(A)/sizeof(A[0]);
    Create(A,n);
    insert(5,0);
    insert(8,4);
    Delete(7);
    cout<<Length(first)<<endl;
    Display(first);
    cout<<endl;
    
    return 0;
}

-----------------------------------------------------------------------
10.)      < All C++ program using Class in Doubly Linked List >

#include <iostream>
using namespace std;

class Node
{
    public:
    Node* prev;
    int data;
    Node* next;
};

class DoublyLinkedList
{
    private:
        Node* head;
    public:
    DoublyLinkedList();
    void Create(int A[],int n);
    void Display();
    ~DoublyLinkedList();
    int Length();
    void Reverse1();
    void Reverse2();
};

DoublyLinkedList::DoublyLinkedList()
{
    head = new Node;
    head->data = 0;
    head->prev = NULL;
    head->next = NULL;
}

void DoublyLinkedList::Create(int A[],int n)
{
    Node *temp,*last;
    head = new Node;
    head->prev = NULL;
    head->next = NULL;
    head->data = A[0];
    last = head;
    
    for(int i=1; i<n; i++)
    {
        temp = new Node;
        temp->prev = head;
        temp->data = A[i];
        temp->next = NULL;
        last->next = temp;
        last = temp;
    }
}

void DoublyLinkedList::Display()
{
    Node *p = head;
    while(p != NULL)
    {
        cout<<p->data<<" "<<flush;
        p = p->next;
    }
}

DoublyLinkedList::~DoublyLinkedList()
{
   Node* p = head;
   while(head)
   {
       head = head->next;
       delete p;
       p = head;
   }
}

int DoublyLinkedList::Length()
{
    Node* p = head;
    int n = 0;
    while(p)
    {
        n = n + 1;
        p = p->next;
    }
    return n;
}

void DoublyLinkedList::Reverse1()
{
    Node* p=head;
    int i = 0,n = 0;
    n = Length();
    int *A;
    A = new int[n];
    while(p)
    {
        A[i] = p->data;
        p = p->next;
        i++;
    }
    p = head;
    i--;
    while(p)
    {
        p->data = A[i];
        p = p->next;
        i--;
    }
}

void  DoublyLinkedList::Reverse2()
{
    Node* r = NULL;
    Node* q = NULL;
    Node* p = head;
    while(p)
    {
        r=q;
        q=p;
        p=p->next;
        q->next = r;
    }
    head = q;
}

int main()
{
    int A[] = {1,2,3,4,5,6};
    int n = sizeof(A)/sizeof(A[0]);
    DoublyLinkedList dll;
    dll.Create(A,n);
    cout<<dll.Length()<<endl;
    dll.Reverse1();
    //dll.Reverse2();
    dll.Display();
    dll.~DoublyLinkedList();
    
    return 0;
}

----------------------------------------------------------------------
11.)    < Finding Intersecting Point of two Linked list >

#include <iostream>
#include <stack>   // stacl lib.
using namespace std;

class Node
{
    public:
    int data;
    Node* next;
};

Node* head = new Node;
Node* second = new Node;

void Create(int A[],int n)
{
     Node* temp;
    Node* tail;
 
    head->data = A[0];
    head->next = nullptr;
    tail = head;
 
    for (int i=1; i<n; i++){
        temp = new Node;
        temp->data = A[i];
        temp->next = nullptr;
        tail->next = temp;
        tail = temp;
    }
}

void Create2(int A[], int n,Node* p)
{
    Node* temp;
    Node* tail;
 
    second->data = A[0];
    second->next = nullptr;
    tail = second;
   
    for (int i=1; i<n; i++){
        temp = new Node;
        temp->data = A[i];
        temp->next = nullptr;
        tail->next = temp;
        tail = temp;
    }
    tail->next = p;
}

void InterSection(Node* A,Node* B)
{
    stack<Node*> stk1;
    while(A != nullptr)
    {
        stk1.push(A);
        A=A->next;
    }
    
    stack<Node*> stk2;
    while(B != nullptr)
    {
        stk2.push(B);
        B=B->next;
    }
    Node* p;
    while(stk1.top() == stk2.top())
    {
        p = stk1.top();
        stk1.pop();
        stk2.pop();
    }
    cout<<p->data<<endl;
}

int main()
{
    int A[] = {1,2,3,4,5};
    int B[] = {1,2,3};
    int n = sizeof(A)/sizeof(A[0]);
    int n1 = sizeof(B)/sizeof(B[0]);
    Create(A,n);
    
    // Intersecting code the linked list.
    Node* p = head;
    int i = 3;
    while(i>0)
    {
        p = p->next;
        i--;
    }
    cout<<p->data<<endl;
    
    
    Create2(B,n1,p);
    InterSection(head,second);
    
    return 0;
}

----------------------------------------------------------------------
12.)     < Polynomial Representation using linked list and add >

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

class Node
{
    public:
    int coeff;
    int exp;
    Node* next;
};

Node* head = NULL;

void Create()
{
    Node* temp,*last = NULL;
    int terms = 0;
    cout<<"\nEnter terms :- \n";
    cin>>terms;
    cout<<"Enter coeff and exp\n";
    for(int i=0;i<terms;i++)
    {
        temp = new Node;
        cin>>temp->coeff>>temp->exp;
        temp->next = NULL;
        if(head == NULL)
        {
            head = last = temp;
        }
        else
        {
           last->next = temp;
           last = temp; 
        }
    }
    
}

long total(Node* p,int x)
{
    long Sum = 0;
    while(p)
    {
        Sum = Sum + p->coeff*pow(x,p->exp);
        p=p->next;
    }
    return Sum;
}

void Display(Node* p)
{
    while(p)
    {
        cout<<p->coeff<<" X "<<p->exp<<"   ";
        p=p->next;
    }
    cout<<endl;
}

int main()
{
    Create();
    Display(head);
    cout<<total(head,2); // x value = 2;
    
    return 0;
}

----------------------------------------------------------------------
13.)    < Sparse Matrix Using Linked List >

#include <iostream>
using namespace std;

class Node
{
    public:
    int row;
    int col;
    int data;
    Node *next;
};

Node *first = NULL;

void Create(int i,int j,int val)
{
    Node *temp = first;
    Node *r;
    if(temp == NULL)
    {
        temp = new Node;
        temp->row = i;
        temp->col = j;
        temp->data = val;
        temp->next = NULL;
        first = temp;
    }
    else
    {
        while(temp->next != NULL)
        {
            temp = temp->next;
        }
        r = new Node;
        r->row = i;
        r->col = j;
        r->data = val;
        r->next = NULL;
        temp->next = r;
    }
}

void Display(Node *p)
{
    while(p)
    {
        cout<<p->row<<" "<<p->col<<" "<<p->data<<"     ";
        p = p->next;
    }
}

int main()
{
    int sparseMatrix[4][5] = {{0,0,3,0,0},{0,0,2,0,2},{0,0,3,0,0},{0,0,0,0,1}};
    for(int i=0;i<4;i++)
    {
        for(int j=0;j<5;j++)
        {
            if(sparseMatrix[i][j] != 0)
            {
                Create(i,j,sparseMatrix[i][j]);
            }
        }
    }
    
    Display(first);
    
    return 0;
}

----------------------------------------------------------------------
14.)    < Stack all operations perform >
     ( push(insert) , pop(delete) , peek (Look) , isEmpty , isFull )

#include <iostream>
using namespace std;

struct Stack // structure
{
    int size;
    int top;
    int *s;
};

void Create(struct Stack *st) // Create
{
    cout<<"Enter Size of stack\n";
    cin>>st->size;
    st->top = -1;
    st->s = new int[st->size];
}

void Display(struct Stack st) // Display
{
    for(int i=st.top; i>=0; i--)
    {
        cout<<st.s[i]<<" ";
    }
}

void push(struct Stack *st,int val) // Insert
{
    if(st->top == st->size-1)
    {
        cout<<"Stack overflow\n";
    }
    else
    {
        st->top++;
        st->s[st->top] = val;
    }
}

int pop(struct Stack *st) // Delete 
{
    int s = 0;
    if(st->top == -1)
    {
        cout<<"Stack Underflow\n";
    }
    else
    {
        s = st->s[st->top--];
    }
    return s;
}

void isEmpty(struct Stack st) // Empty or not
{
    if(st.top == -1)
    {
        cout<<"Empty"<<endl;
    }
    else 
    {
        cout<<"Value Available"<<endl;
    }
}

void isFull(struct Stack st) // full or not
{
    if(st.top == st.size-1)
    {
        cout<<"Full\n";
    }
    else
    {
        cout<<"Space Available\n";
    }
}

void StackTop(struct Stack st)  // Pointing index
{
    if(st.top == -1)
    {
        cout<<"-1\n";
    }
    else
    {
        cout<<"Top is pointing :- "<<st.s[st.top]<<endl;
    }
}

void peek(struct Stack st,int index)  // Looking Index
{
    if(st.top-index+1 < 0 || index > st.top+1)
    {
        cout<<"Invalid index\n";
    }
    else
    {
        cout<<"Index value is :- "<<st.s[st.top-index+1]<<endl;
    }
}

int main()
{
    struct Stack st;
    Create(&st);
    
    push(&st,3);
    push(&st,2);
    push(&st,1);
    push(&st,4);
    
    cout<<"Deleted element is :- "<<pop(&st)<<endl;
    
    isEmpty(st);
    isFull(st);
    StackTop(st);
    peek(st,3);
    
    Display(st);
    
    return 0;
}

----------------------------------------------------------------------
15.)     < Stack using linked list >

#include <iostream>
using namespace std;

class Node
{
    public:
    int data;
    struct Node *next;
};
Node *head = NULL;

void push(int val)
{
    Node *temp=NULL;
    if(head == NULL)
    {
        head = new Node;
        head->data = val;
        head->next = NULL;
        head;
   }
   else
   {
       Node *temp = new Node;
       temp->data = val;
       temp->next = head;
       head = temp;
   }
   
}

int pop()
{
    int x = -1;
    if(head == NULL)
    {
        cout<<" Stack underflow \n";
    }
    else
    {
        Node *p = head;
        head = head->next;
        x = p->data;
        delete p;
    }
    return x;
}

int isFull() 
{
    Node* t = new Node;
    int r = t ? 1 : 0;
    delete t;
    return r;
}

void Display(Node *p)
{
    while(p != NULL)
    {
        cout<<p->data<<" ";
        p = p->next;
    }
}

int main()
{
    push(3);
    push(4);
    push(5);
    Display(head);
    cout<<endl;
    cout<<isFull(); // In linked list always full .
    
    return 0;
}

----------------------------------------------------------------------
16.)     < Paranthesis Matching in program of C++ >

#include <iostream>
#include <cstring>
using namespace std;

class Node
{
    public:
    char data;
    Node *next;
};

class Stack 
{
    private:
        Node *top;
    public:
        Stack();
        ~Stack();
        char pop();
        int isEmpty();
        void push(char val);
        int isBalanced(char* a);
};

Stack::Stack()
{
    top = nullptr;
}

Stack::~Stack()
{
    Node *p = top;
    while(top != NULL)
    {
        top = top->next;
        delete p;
        p = top;
    }
}

void Stack::push(char val)
{
    Node *temp=NULL;
    if(top == NULL)
    {
        top = new Node;
        top->data = val;
        top->next = NULL;
        top;
   }
   else
   {
       Node *temp = new Node;
       temp->data = val;
       temp->next = top;
       top = temp;
   }
   
}

char Stack::pop()
{
    int x = -1;
    if(top == nullptr)
    {
        cout<<" Stack underflow \n";
    }
    else
    {
        Node *p = top;
        top = top->next;
        x = p->data;
        delete p;
    }
    return x;
}

int isBalanced(char a[])
{
    Stack stk;
    
        for(int i=0;i<strlen(a);i++)
        {
            if(a[i] == '(')
            {
                stk.push(a[i]);   
            }
            else if(a[i] == ')')
            {
                if(stk.isEmpty())
                {
                    return false;
                }
                else
                {
                    stk.pop();
                }
            }
        }
        return stk.isEmpty() ? true:false;
}

int Stack::isEmpty() 
{
    return top ? 0 : 1;
}


int main()
{
    char E[] = "((a+b)*(c-d))";
    cout << isBalanced(E) << endl;
    
    return 0;
}

----------------------------------------------------------------------
17.)     < Infix to postfix convert in c++ program >

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

struct Node
{
    char data;
    struct Node *next;
}*top = NULL;

void push(char val)
{
    struct Node *temp = new Node ;
    
    if(temp == NULL)
    {
        cout<<"Stack overflow \n";
    }
    else
    {
        temp->data = val;
        temp->next = top;
        top = temp;
    }
}

char pop()
{
    char x = -1;
    struct Node *p;
    if(top == NULL)
    {
        cout<<"Stack underflow\n";
    }
    else
    {
        p = top;
        top = top->next;
        x = p->data;
        delete p;
    }
    return x;
}

int idEmpty()
{
    if(top == NULL)
    return -1;
    else
    return 0;
}

int variable(char str)
{
    if(str == '+' || str == '-' || str == '*' || str == '/')
    return 0;
    else
    return 1;
}

int pre(char str)
{
    if(str == '+' || str == '-')
    {
        return 1;
    }
    else if(str == '*' || str == '/')
    {
        return 2;
    }
    return 0;
}

char *InfixToPostfix(char *infix)
{
    int i=0,j=0;
    int size = strlen(infix);
    char *postfix ;
    postfix = new char[size+2];
    
    while(infix[i] != '\0')
    {
        if(variable(infix[i]))
        {
            postfix[j++] = infix[i++];
        }
        else
        {
            if(top == NULL)
                push(infix[i++]);
            else if(pre(infix[i]) > pre(top->data))
            {
                push(infix[i++]);
            }
            else
            {
                postfix[j++] = pop();
            }
        }
    }
    while(top != NULL)
    {
        postfix[j++] = pop();
    }
    postfix[j] = '\0';
    
    return postfix;
   // delete []postfix;
}

int main()
{
    char str[] = "a+b*c-d/e";
    push('#');
    char *stfix=InfixToPostfix(str);
 
    cout<<stfix;
    
    return 0;
}

-----------------------------------------------------------------------
18.)   < Queue all operations Perform using array in C++ >

#include <iostream>
using namespace std;

struct Queue
{
    int size;
    int front;
    int rear;
    int *s;
};

void Create(struct Queue *q1)
{
    cout<<"Enter a queue :- "<<endl;
    cin>>q1->size;
    q1->front = q1->rear = -1;
    q1->s = new int[q1->size];
}

void Enqueue(struct Queue *q1,int x)
{
    if(q1->rear == q1->size-1)
    {
        cout<<"Queue is Full\n";
    }
    else
    {
        q1->rear++;
        q1->s[q1->rear]=x;
    }
}

int Dequeue(struct Queue *q1)
{
    int x = -1;
    if(q1->front == q1->rear)
    {
        cout<<"Can not delete Queue is already Empty.\n";
    }
    else
    {
        q1->front++;
        x = q1->s[q1->front];
    }
    return x;
}

void Display(struct Queue q1)
{
    for(int i=q1.front+1; i<=q1.rear; i++)
    {
        cout<<q1.s[i]<<"  ";
    }
    
}

void isEmpty(struct Queue q1)
{
    if(q1.front == -1 && q1.rear == -1)
    {
        cout<<"Empty \n";
    }
    else
        cout<<"Not Empty \n";
}

void isFull(struct Queue q1)
{
    if( q1.rear == q1.size-1)
    {
        cout<<"\n Queue is full \n";
    }
    else
    {
        cout<<"\nQueue is not full\n";
    }
}

int main()
{
    struct Queue q1;
    Create(&q1);
    Enqueue(&q1,5);
    Enqueue(&q1,6);
    Enqueue(&q1,9);
    //Dequeue(&q1);
    
    Display(q1);
    cout<<endl;
    isEmpty(q1);
    isFull(q1);
    
    return 0;
}

-----------------------------------------------------------------------
19.)     < Queue all operations Perform using Linked-list in C++ >

#include <iostream>
using namespace std;

class CircularQueue
{
    private:
    
    int size;
    int front;
    int rear;
    int *s;
    
    public:
    
    CircularQueue(int size);
    ~CircularQueue();
    void isEmpty();
    void isFull();
    void Enqueue(int val);
    int Dequeue();
    void Display();
    
};

CircularQueue::CircularQueue(int size)
{
    this->size = size;
    front = 0;
    rear = 0;
    s = new int[size];
}

CircularQueue::~CircularQueue()
{
    delete []s;
}

void CircularQueue::isEmpty()
{
    if(front == rear)
    {
        cout<<"CircularQueue is Empty\n";   
    }
    else
    {
        cout<<"CircularQueue is not Empty\n";
    }
}

void CircularQueue::isFull()
{
    if((rear+1)%size == front)
    {
        cout<<"CircularQueue is full\n";
    }
    else
    {
        cout<<"CircularQueue is not full\n";
    }
}

void CircularQueue::Enqueue(int val)
{
    if((rear+1)%size == front)
    {
        cout<<"Queue is Full \n";
    }
    else
    {
        rear = (rear+1)%size;
        s[rear] = val;
    }
}

int CircularQueue::Dequeue()
{
    int x = -1;
    if(front == rear)
    {
        cout<<"CircularQueue is Empty\n";
    }
    else
    {
        front = (front+1)%size;
        x = s[front];
    }
    return -1;
}

void CircularQueue::Display()
{
    int i = front + 1;
    do
    {
        cout<<s[i]<<"  ";
        i = (i+1)%size;
    }while(i != (rear+1)%size);
}

int main()
{
    
    int size = -1;
    cout<<"Enter a size of CircularQueue :- \n";
    cin>>size;
    CircularQueue q1 = CircularQueue(size+1);
    q1.Enqueue(3);
    q1.Enqueue(4);
    q1.Enqueue(5);
    q1.Enqueue(6);
    q1.Dequeue();
    q1.isFull();
    q1.isEmpty();
    q1.Display();
    return 0;
}

----------------------------------------------------------------------
20.)        < Queue using Linked List in c++ using class >

#include <iostream>
using namespace std;

class Node
{
    public:
    int data;
    Node *next;
};

class Queue
{
    private:
    Node *front;
    Node *rear;
    
    public:
    
    Queue();
    
    void Display();
    int Dequeue();
    void Enqueue(int val);
    void isFull();
    void isEmpty();
    void first();
    void last();
    ~Queue();
    
};

Queue::Queue()
{
    rear = nullptr;
    front = nullptr;
}

void Queue::Display()
{
    Node *p = front;
    while(p)
    {
        cout<<p->data<<" ";
        p = p->next;
    }
}

int Queue::Dequeue()
{
    Node *p = front;
    int x = -1;
    if(front != NULL)
    {
        front = front->next;
        x = p->data;
        delete p;
    }
    else
    {
        cout<<"Queue is Empty \n";
    }
    return x;
}

void Queue::Enqueue(int val)
{
    Node *p = new Node;
    if(p == nullptr)
    {
        cout<<"Queue is full \n";
    }
    else
    {
        p->data = val;
        p->next = nullptr;
        if(front == nullptr)
        {
            front = p;
            rear = p;
        }
        else
        {
            rear->next = p;
            rear = p;
        }
    }
}

void Queue::isFull()
{
    if(front != NULL && rear != NULL)
    {
        cout<<"Queue is Full \n";
    }
    else
    {
        cout<<"Queue is not Full\n";
    }
}

void Queue::isEmpty()
{
    if(front == NULL)
    {
        cout<<"Queue is Empty\n";
    }
    else
    {
        cout<<"Queue is not Empty\n";
    }
}

Queue::~Queue()
{
    Node *p = front;
    while(front)
    {
        front = front->next;
        delete p;
        p = front;
    }
}

void Queue::first()
{
    if(front)
    {
        cout<<front->data<<endl;
    }
    else
    {
        cout<<"Queue is Empty\n";
    }
}

void Queue::last()
{
    if(rear)
    {
        cout<<rear->data<<endl;
    }
    else
    {
        cout<<"Queue is Empty\n";
    }
}

int main()
{
    Queue q1 = Queue();
    q1.Enqueue(3);
    q1.Enqueue(4);
    q1.Enqueue(5);
    q1.Enqueue(6);
    q1.Dequeue();
    q1.isEmpty();
    q1.isFull();
    q1.Display();
    cout<<endl;
    q1.first();
    q1.last();
    
    return 0;
}

----------------------------------------------------------------------
21.)      < Priority Queue >

#include <iostream>
using namespace std;

class Node
{
    public:
    char data;
    Node *next;
};

class Queue
{
    private:
    Node *front;
    Node *rear;
    
    public:
    
    Queue();
    void Display();
    char Dequeue();
    void Enqueue(char val);
    ~Queue();
    
};

Queue::Queue()
{
    rear = nullptr;
    front = nullptr;
}

void Queue::Display()
{
    Node *p = front;
    while(p)
    {
        cout<<p->data<<" ";
        p = p->next;
    }
}

char Queue::Dequeue()
{
    Node *p = front;
    char x = -1;
    if(front != NULL)
    {
        front = front->next;
        x = p->data;
        delete p;
    }
    else
    {
        cout<<"Queue is Empty \n";
    }
    return x;
}

void Queue::Enqueue(char val)
{
    Node *p = new Node;
    if(p == nullptr)
    {
        cout<<"Queue is full \n";
    }
    else
    {
        p->data = val;
        p->next = nullptr;
        if(front == nullptr)
        {
            front = p;
            rear = p;
        }
        else
        {
            rear->next = p;
            rear = p;
        }
    }
}

Queue::~Queue()
{
    Node *p = front;
    while(front)
    {
        front = front->next;
        delete p;
        p = front;
    }
}

int main()
{
    Queue q1 = Queue();
    Queue q2 = Queue();
    Queue q3 = Queue();
    
    int size,p;
    char c;
    cout<<"Enter length of character:- \n";
    cin>>size;
    for(int i=0;i<size-1;i++)
    {
        cout<<"Enter character :- \n";
        cin>>c;
        cout<<"Enter Priority (1,2,3):- \n";
        cin>>p;
        
        if(p == 1)
        {
            q1.Enqueue(c);
        }
        else if(p == 2)
        {
            q2.Enqueue(c);
        }
        else if(p == 3)
        {
            q3.Enqueue(c);
        }
        else
        {
            cout<<"Invalid opposition\n";
        }
    }
    
    cout<<"\nQueue 1 Data :- \n";
    q1.Display();
    cout<<"\nQueue 2 Data :- \n";
    q2.Display();
    cout<<"\nQueue 3 Data :- \n";
    q3.Display();
    
    return 0;
}

----------------------------------------------------------------------
22.)      < Only Queue program for storing address of Tree >

class Queue
{
    private:
    
    int size;
    int front;
    int rear;
    Node** Q;
    
    public:
    
    Queue(int size);
    ~Queue();
    void Enqueue(Node *p);
    Node* Dequeue();
    bool isEmpty();
    bool isFull();
};

Queue::Queue(int size)
{
    this.size = size;
    front = -1;
    rear = -1;
    Q = new Node*[size];
}

Queue::~Queue()
{
    delete []Q;
}

void Queue::Enqueue(Node *p)
{
    if(isFull())
    {
       cout<<"Queue Overflow "<<endl; 
    }
    else
    {
        rear++;
        Q[rear] = p;
    }
}

Node* Queue::Dequeue(Node *p)
{
    Node* x = nullptr;
    if(isEmpty())
    {
        cout<<"Queue underflow \n";
    }
    else
    {
        front++;
        x = Q[front];
    }
}

bool Queue::isFull()
{
    if(rear == size-1)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool Queue::isEmpty()
{
    if(rear == front)
    {
        return true;
    }
    else
    {
        return false;
    }
}

----------------------------------------------------------------------
23.)     < Binary Tree Program in c++ >
          ( Please Enter -1 to null value )

#include <iostream>
using namespace std;

class Node
{
    public:
    
    Node* lchild = nullptr;
    int data;
    Node* rchild = nullptr;
};

class Queue
{
    private:
    
    int size;
    int front;
    int rear;
    Node** Q;
    
    public:
    
    Queue(int size);
    ~Queue();
    void Enqueue(Node *p);
    Node* Dequeue();
    bool isEmpty();
    bool isFull();
};

Queue::Queue(int size)
{
    this->size = size;
    front = -1;
    rear = -1;
    Q = new Node*[size];
}

Queue::~Queue()
{
    delete []Q;
}

void Queue::Enqueue(Node *p)
{
    if(isFull())
    {
       cout<<"Queue Overflow "<<endl; 
    }
    else
    {
        rear++;
        Q[rear] = p;
    }
}

Node* Queue::Dequeue()
{
    Node* x = nullptr;
    if(isEmpty())
    {
        cout<<"Queue underflow \n";
    }
    else
    {
        front++;
        x = Q[front];
    }
    return x;
}

bool Queue::isFull()
{
    if(rear == size-1)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool Queue::isEmpty()
{
    if(rear == front)
    {
        return true;
    }
    else
    {
        return false;
    }
}

Node* root = new Node;

void createTree()
{
    Node* t;
    Node* x;
    int val = 0;
    Queue q(10);
    
    cout<<"Enter root Data :- "<<flush;
    cin>>val;
    
    root->lchild = nullptr;
    root->data = val;
    root->rchild = nullptr;
    q.Enqueue(root);
    
    while(!q.isEmpty())
    {
        x = q.Dequeue();
        cout<<"Enter left child of "<<x->data<<" :- "<<flush;
        cin>>val;
            
        if(val != -1)
        {
            t = new Node;
            t->lchild = nullptr;
            t->data = val;
            t->rchild = nullptr;
            x->lchild = t;
            q.Enqueue(t);
        }
        
        cout<<"Enter Rigth child of "<<x->data<<" :- "<<flush;
        cin>>val;
        
        if(val != -1)
        {
            t = new Node;
            t->lchild = nullptr;
            t->data = val;
            t->rchild = nullptr;
            x->rchild = t;
            q.Enqueue(t);
        }
    }
    
}

void Preorder(Node *p)
{
    if(p)
    {
        cout<<p->data<<", -> "<<flush;
        Preorder(p->lchild);
        Preorder(p->rchild);
    }
}

void Inorder(Node *p)
{
    if(p)
    {
        Inorder(p->lchild);
        cout<<p->data<<", -> "<<flush;
        Inorder(p->rchild);
    }
}

void Postorder(Node *p)
{
    if(p)
    {
        Postorder(p->lchild);
        Postorder(p->rchild);
        cout<<p->data<<", -> "<<flush;
    }
}

int main()
{
    createTree();
    
    Preorder(root);
    cout<<"End Preorder."<<endl;
    
    Inorder(root);
    cout<<"End Inorder."<<endl;
    
    Postorder(root);
    cout<<"End Postorder."<<endl;
    
    return 0;
}

----------------------------------------------------------------------
24.)     < Iterative code of (Preorder,Inorder,Postorder,height) >

#include <iostream>
#include <queue>
#include <stack>

using namespace std;

class Node
{
    public:
        Node* lchild;
        int data;
        Node* rchild;
};

class Tree
{
    private:
        Node* root;
    public:
        Tree();
        ~Tree();
        void CreateTree();
        void Preorder(Node *p);
        void Preorder() { Preorder(root); }  // Passing Private Parameter in Constructor
        void Inorder(Node *p);
        void Inorder() { Inorder(root); }
        void Postorder(Node *p);
        void Postorder() { Postorder(root); }
        void Levelorder(Node *p);
        void Levelorder() { Levelorder(root); }
        int Height(Node *p);
        int Height() { return Height(root); }
        void iterativePreorder(Node* p);
        void iterativePreorder() { iterativePreorder(root); }
        void iterativeInorder(Node* p);
        void iterativeInorder() { iterativeInorder(root); }
        void iterativePostorder(Node* p);
        void iterativePostorder() { iterativePostorder(root); }
};

Tree::Tree()
{
    root = nullptr;
}

Tree::~Tree()
{
    // TODO
}

void Tree::CreateTree()
{
    Node* p;
    Node* t;
    int x;
    queue<Node*> q;
    
    root= new Node;
    cout<<"Enter root data "<<flush;
    cin>>x;
    root->lchild = nullptr;
    root->data = x;
    root->rchild = nullptr;
    q.emplace(root);
    
    while(!q.empty())
    {
        p = q.front();
        q.pop();
        
        cout<<"Enter left child data of "<<p->data<<": "<<flush;
        cin>>x;
        if(x != -1)
        {
            t = new Node;
            t->lchild = nullptr;
            t->data = x;
            t->rchild = nullptr;
            p->lchild = t;
            q.emplace(t);
        }
        
        cout<<"Enter Rigth child data of "<<p->data<<": "<<flush;
        cin>>x;
        if(x != -1)
        {
            t = new Node;
            t->lchild = nullptr;
            t->data = x;
            t->rchild = nullptr;
            p->rchild = t;
            q.emplace(t);
        }
    }
}

void Tree::Preorder(Node *p)
{
    if(p)
    {
        cout<<p->data<<", "<<flush;
        Preorder(p->lchild);
        Preorder(p->rchild);
    }
}

void Tree::Inorder(Node *p)
{
    if(p)
    {
        Inorder(p->lchild);
        cout<<p->data<<", "<<flush;
        Postorder(p->rchild);
    }
}

void Tree::Postorder(Node *p)
{
    if(p)
    {
        Postorder(p->lchild);
        Postorder(p->rchild);
        cout<<p->data<<", "<<flush;
    }
}
//  Level
void Tree::Levelorder(Node *p)
{
    queue<Node*> q;
    cout<<root->data<<", "<<flush;
    q.emplace(root);
    
    while(!q.empty())
    {
        p = q.front();
        q.pop();
        
        if(p->lchild)
        {
            cout<<p->lchild->data<<", "<<flush;
            q.emplace(p->lchild);
        }
        
        if(p->rchild)
        {
            cout<<p->rchild->data<<", "<<flush;
            q.emplace(p->rchild);
        }
    }
}

int Tree::Height(Node *p)
{
    int l = 0;
    int r = 0;
    if(p == nullptr)
    {
        return 0;
    }
    
    l = Height(p->lchild);
    r = Height(p->rchild);
    
    if(l>r)
    {
        return l+1;
    }
    else
    {
        return r+1;
    }
}
    
void Tree::iterativePreorder(Node *p)
{
    stack<Node*> stk;
    while(p != nullptr || !stk.empty())
    {
        if(p != nullptr)
        {
            cout<<p->data<<", "<<flush;
            stk.emplace(p);
            p = p->lchild;
        }
        else
        {
            p = stk.top();
            stk.pop();
            p=p->rchild;
        }
    }
    cout<<endl;
}

void Tree::iterativeInorder(Node *p)
{
    stack<Node*> stk;
    while(p != nullptr || !stk.empty())
    {
        if(p != nullptr)
        {
            stk.emplace(p);
            p = p->lchild;
        }
        else
        {
            p = stk.top();
            stk.pop();
            cout<<p->data<<", "<<flush;
            p = p->rchild;
        }
    }
    cout<<endl;
}

void Tree::iterativePostorder(Node *p)
{
    stack<long int> stk;
    long int temp;
    while(p != nullptr || ! stk.empty())
    {
        if(p != nullptr)
        {
            stk.emplace((long int)p);
            p = p->lchild;
        }
        else
        {
            temp = stk.top();
            stk.pop();
            if(temp > 0)
            {
                stk.emplace(-temp);
                p = ((Node*)temp)->rchild;
            }
            else
            {
                cout<<((Node*)(-1 * temp))->data<<", "<<flush;
                p = nullptr;
            }
        }
    }
    cout<<endl;
}

int main()
{
    Tree bt;
    
    bt.CreateTree();
    cout<<endl;
    
    cout << "Preorder: " << flush;
    bt.Preorder();
    cout << endl;
    
    cout << "Inorder: " << flush;
    bt.Inorder();
    cout << endl;
 
    cout << "Postorder: " << flush;
    bt.Postorder();
    cout << endl;
    
    cout << "Levelorder: " << flush;
    bt.Levelorder();
    cout << endl;
    
    cout << "Height: " << bt.Height() << endl;
    
    
    
    return 0;
}

----------------------------------------------------------------------
25.)      <  >

#include <iostream>
#include <stack>
#include <queue>
using namespace std;

class Node
{
    public: 
    Node* rchild;
    int data;
    Node* lchild;
};

class Tree
{
    private: 
    
    Node* root;
    
    public:
    
    Tree();
    ~Tree();
    void createTree();
    void Preorder(Node* p);
    void Preorder() { Preorder(root) ;}
    void Inorder(Node* p);
    void Inorder() { Inorder(root) ; }
    void Postorder(Node* p);
    void Postorder() { Postorder(root) ; }
    void Levelorder(Node* p);
    void Levelorder() { Levelorder(root); }
    int Height(Node* p);
    int Height() { return Height(root); }
    void IterativePreorder(Node* p);
    void IterativePreorder() { IterativePreorder(root); }
    void IterativeInorder(Node* p);
    void IterativeInorder() { IterativeInorder(root); }
    void IterativePostorder(Node* p);
    void IterativePostorder() { IterativePostorder(root); }
    int Count(Node*);
    int Count()  { return  Count(root); }
    int Sum(Node* p);
    int Sum() { return Sum(root); }
    int degree2NodeCount(Node* p);
    int degree2NodeCount() { return degree2NodeCount(root); }
    int degree1NodeCount(Node* p);
    int degree1NodeCount() {return degree1NodeCount(root); }
    void DestroyTree(Node* p);
    void DestroyTree()  { Destroy(root); }
};

Tree::Tree()
{
    root = nullptr;
}

Tree::~Tree()
{
     //TODO
}

void Tree::createTree()
{
    Node *t;
    Node *n;
    int x;
    queue<Node*> q1;
    
    root = new Node;
    cout<<"Enter root data"<<flush;
    cin>>x;
    root->lchild = nullptr;
    root->data = x;
    root->rchild = nullptr;
    q1.emplace(root);
    
    while(!q1.empty())
    {
        n = q1.front();
        q1.pop();
        
        cout<<"Enter left child of "<<n->data<<", "<<flush;
        cin>>x;
        if(x != -1)
        {
            t = new Node;
            t->lchild = nullptr;
            t->data = x;
            t->rchild = nullptr;
            n->lchild = t;
            q1.emplace(t);
        }
        
        cout<<"Enter rigth child of "<<n->data<<", "<<flush;
        cin>>x;
        if(x>0)
        {
            t = new Node;
            t->lchild = nullptr;
            t->data = x;
            t->rchild = nullptr;
            n->rchild = t;
            q1.emplace(t);
        }
    }
}

void Tree::Preorder(Node *p)
{
    if(p)
    {
        cout<<p->data<<", "<<flush;
        Preorder(p->lchild);
        Preorder(p->rchild);
    }
}

void Tree::Inorder(Node *p)
{
    if(p)
    {
        Inorder(p->lchild);
        cout<<p->data<<", "<<flush;
        Inorder(p->rchild);
    }
}

void Tree::Postorder(Node *p)
{
    if(p)
    {
        Postorder(p->lchild);
        Postorder(p->rchild);
        cout<<p->data<<", "<<flush;
    }
}

void Tree::Levelorder(Node* p)
{
   queue<Node*> q1;
   cout<<p->data<<", "<<flush;
   q1.emplace(p);
   
   while(!q1.empty())
   {
       p = q1.front();
       q1.pop();
       
       if(p->lchild)
       {
           cout<<p->lchild->data<<", "<<flush;
           q1.emplace(p->lchild);
       }
       if(p->rchild)
       {
           cout<<p->rchild->data<<", "<<flush;
           q1.emplace(p->rchild);
       }
   }
}

int Tree::Height(Node* p)    // Finding Height of the Tree.
{
    int l=0,k=0;
    
    if(p == nullptr)
    {
        return 0;
    }
    l = Height(p->lchild);
    k = Height(p->rchild);
    
    if(l>k)
    {
        return l+1;
    }
    else
    {
        return k+1;
    }
}

void Tree::IterativePreorder(Node* p)
{
    stack<Node*> stk;
    
    while(!stk.empty() || p != nullptr)
    {
        if(p!=nullptr)
        {
            cout<<p->data<<", "<<flush;
            stk.emplace(p);
            p = p->lchild;
        }
        else
        {
            p = stk.top();
            stk.pop();
            p = p->rchild;
        }
    }
}

void Tree::IterativeInorder(Node* p)
{
    stack<Node*> stk;
    
    while(!stk.empty() || p != nullptr)
    {
        if(p != nullptr)
        {
            stk.emplace(p);
            p = p->lchild;
        }
        else
        {
            p = stk.top();
            stk.pop();
            cout<<p->data<<", "<<flush;
            p = p->rchild;
        }
    }
}

void Tree::IterativePostorder(Node* p)
{
     stack<long int> stk;
    long int temp;
    
    while (p != nullptr || ! stk.empty()){
        if (p != nullptr){
            stk.emplace((long int)p);
            p = p->lchild;
        } else {
            temp = stk.top();
            stk.pop();
            if (temp > 0){
                stk.emplace(-temp);
                p = ((Node*)temp)->rchild;
            } else {
                cout << ((Node*)(-1 * temp))->data << ", " << flush;
                p = nullptr;
            }
        }
    }
    cout << endl;
} 

int Tree::Count(Node* p)
{
    int x;
    int y;
    if(p != nullptr)
    {
        x = Count(p->lchild);
        y = Count(p->rchild);
        return x+y+1;
    }
    
    return 0;
}

int Tree::Sum(Node* p)
{
    int x;
    int y;
    if(p != nullptr)
    {
        x = Sum(p->lchild);
        y = Sum(p->rchild);
        return x+y+p->data;
    }
    return 0;
}

int Tree::degree2NodeCount(Node *p)
{
    int x;
    int y;
    if(p != nullptr)
    {
        x = degree2NodeCount(p->lchild);
        y = degree2NodeCount(p->rchild);
        if(p->lchild && p->rchild)
        {
            return x+y+1;
        }
        else
        {
            return x+y;
        }
    }
    return 0;
}

int Tree::degree1NodeCount(Node* p)
{
    int x;
    int y;
    if(p != nullptr)
    {
        x = degree1NodeCount(p->lchild);
        y = degree1NodeCount(p->rchild);
        if(p->lchild != NULL || p->rchild != NULL)
        {
            return x+y;
        }
        else
        {
            return x+y+1;
        }
    }
    return 0;
}

void Tree::DestroyTree(Node* p)
{
    if(p != nullptr)
    {
        DestroyTree(p->lchild);
        DestroyTree(p->rchild);
        delete p;
    }
}

int main()
{
    Tree bt;
    
    bt.createTree();
    cout<<endl;
    
    cout<<"Preorder: "<<flush;
    bt.Preorder();
    cout<<endl;
    
    cout<<"Inorder: "<<flush;
    bt.Inorder();
    cout<<endl;
    
    cout<<"Postorder: "<<flush;
    bt.Postorder();
    cout<<endl;
    
    cout<<"Levelorder: "<<flush;
    bt.Levelorder();
    cout<<endl;
    
    cout<<"Height: "<<flush;
    cout<<bt.Height();
    cout<<endl;
    
    cout<<"Iterative Preorder: "<<flush;
    bt.IterativePreorder();
    cout<<endl;
    
    cout<<"Iterative Inorder: "<<flush;
    bt.IterativeInorder();
    cout<<endl;
    
    cout<<"Iterative Postorder: "<<flush;
    bt.IterativePostorder();
    cout<<endl;
    
    cout<<"Count : "<<flush;
    cout<<bt.Count();
    cout<<endl;

    cout<<"Sum :- "<<flush;
    cout<<bt.Sum();
    cout<<endl;

    cout<<"Degree of 2 NodeCount is :- "<<bt.degree2NodeCount()<<flush;
    cout<<endl;
    cout<<"Degree of 1 NodeCount is :- "<<bt.degree1NodeCount()<<flush;
    cout<<endl;
    
    bt.DestroyTree();
    
    return 0;
}

----------------------------------------------------------------------
What is Static Variable in C++ :-
                   
                 Initialized only once as they are allocated space.

----------------------------------------------------------------------
26.)     < GenerateFromTraversal ( Taking Inorder and Preorder ) >

Node* generateFromTraversal(int inorder[], int preorder[], int inStart, int inEnd);
int searchInorder(int inArray[], int inStart, int inEnd, int data);


int searchInorder(int inArray[], int inStart, int inEnd, int data)
{
    for(int i=inStart; i<=inEnd; i++)
    {
        if(inArray[i] == data)
        {
            return i;
        }
    }
    return -1;
}

Node* Tree::generateFromTraversal(int *inorder, int *preorder, int inStart, int inEnd)
{
    static int preIndex = 0;
    
    if(inStart > inEnd)
    {
        return nullptr;
    }
    
    Node* node = new Node(preorder[preIndex++]);
    
    if(instart == inEnd)
    {
        return node;
    }
    
    int splitIndex = searchInorder(inorder, inStart, inEnd, node->data);
    node->lchild = generateFromTraversal(inorder, preorder, inStart, splitIndex-1);
    node->rchild = generateFromTraversal(inorder, preorder, splitIndex+1, inEnd);
    
    return node;
}

int preorder[] = {4,7,9,6,3,2,5,8,1};
int inorder[] = {7,6,9,3,4,5,8,2,1};
int size = sizeof(inorder)/sizeof(inorder[0])-1;

Node* T = bt.generateFromTraversal(inorder,preorder,0,size)
bt.Preorder(T);

----------------------------------------------------------------------
27.)     < Binary Search Tree , Insert , Search, Print >

#include <iostream>
using namespace std;

class Node
{
    public: 
    
        Node* lchild;
        int data;
        Node* rchild;
};

class BST
{
    private: 
    
        Node* root;
    
    public:
         
        BST(){ root = nullptr; }
        void Insert(int key);
        void Inorder(Node* p);
        void Inorder() { Inorder(root); }
        Node* Search(int key);
};

void BST::Insert(int key)
{
    Node* t = root;
    Node* p;
    Node* r;
    
    if(root == nullptr)
    {
        p = new Node;
        p->lchild = nullptr;
        p->data = key;
        p->rchild = nullptr;
        root = p;
        return;
    }
    
    while(t != nullptr)
    {
        r = t;
        if(key < t->data)
        {
            t = t->lchild;
        }
        else if(key > t->data)
        {
            t = t->rchild;
        }
        else
        {
            return;
        }
    }
    
    p = new Node;
    p->lchild = nullptr;
    p->data = key;
    p->rchild = nullptr;
    
    if(key < r->data)
    {
        r->lchild = p;
    }
    else
    {
        r->rchild = p;
    }
}

void BST::Inorder(Node* p)
{
    if(p)
    {
        Inorder(p->lchild);
        cout<<p->data<<", "<<flush;
        Inorder(p->rchild);
    }
}

Node* BST::Search(int key)
{
    Node* p = root;
    while(p != nullptr)
    {
        if(p->data == key)
        {
            return p;
        }
        else if(key < p->data)
        {
            p = p->lchild;
        }
        else 
        {
            p = p->rchild;
        }
    }
    return nullptr;
}

int main()
{
    BST b1;
    
    b1.Insert(23);
    b1.Insert(2);
    b1.Insert(24);
    
    Node* p = b1.Search(24);
    cout<<p->data<<endl;
    
    b1.Inorder();
    
    return 0;
}

----------------------------------------------------------------------
28.)     < BST From Pre-Order Using STL- StackC++  (in pre-order make BST using stack)>

#include <iostream>
#include <stack>

using namespace std;
 
class Node{
public:
    Node* lchild;
    int data;
    Node* rchild;
};
 
class BST{
private:
    Node* root;
public:
    BST(){ root = nullptr; }
    Node* getRoot(){ return root; }
    void iInsert(int key);
    void Inorder(Node* p);
    Node* iSearch(int key);
    Node* rInsert(Node* p, int key);
    Node* rSearch(Node* p, int key);
    Node* Delete(Node* p, int key);
    int Height(Node* p);
    Node* InPre(Node* p);
    Node* InSucc(Node* p);
    void createFromPreorder(int pre[], int n);
};
 
void BST::iInsert(int key) {
 
    Node* t = root;
    Node* p;
    Node* r;
 
    // root is empty
    if (root == nullptr){
        p = new Node;
        p->data = key;
        p->lchild = nullptr;
        p->rchild = nullptr;
        root = p;
        return;
    }
 
    while(t != nullptr){
        r = t;
        if (key < t->data){
            t = t->lchild;
        } else if (key > t->data){
            t = t->rchild;
        } else {
            return;
        }
    }
 
    // Now t points at NULL and r points at insert location
    p = new Node;
    p->data = key;
    p->lchild = nullptr;
    p->rchild = nullptr;
 
    if (key < r->data){
        r->lchild = p;
    } else {
        r->rchild = p;
    }
 
}
 
void BST::Inorder(Node* p) {
    if (p){
        Inorder(p->lchild);
        cout << p->data << ", " << flush;
        Inorder(p->rchild);
    }
}
 
Node* BST::iSearch(int key) {
    Node* t = root;
    while (t != nullptr){
        if (key == t->data){
            return t;
        } else if (key < t->data){
            t = t->lchild;
        } else {
            t = t->rchild;
        }
    }
    return nullptr;
}
 
Node* BST::rInsert(Node *p, int key) {
    Node* t;
    if (p == nullptr){
        t = new Node;
        t->data = key;
        t->lchild = nullptr;
        t->rchild = nullptr;
        return t;
    }
 
    if (key < p->data){
        p->lchild = rInsert(p->lchild, key);
    } else if (key > p->data){
        p->rchild = rInsert(p->rchild, key);
    }
    return p;  // key == p->data?
}
 
Node* BST::rSearch(Node *p, int key) {
    if (p == nullptr){
        return nullptr;
    }
 
    if (key == p->data){
        return p;
    } else if (key < p->data){
        return rSearch(p->lchild, key);
    } else {
        return rSearch(p->rchild, key);
    }
}
 
Node* BST::Delete(Node *p, int key) {
    Node* q;
 
    if (p == nullptr){
        return nullptr;
    }
 
    if (p->lchild == nullptr && p->rchild == nullptr){
        if (p == root){
            root = nullptr;
        }
        delete p;
        return nullptr;
    }
 
    if (key < p->data){
        p->lchild = Delete(p->lchild, key);
    } else if (key > p->data){
        p->rchild = Delete(p->rchild, key);
    } else {
        if (Height(p->lchild) > Height(p->rchild)){
            q = InPre(p->lchild);
            p->data = q->data;
            p->lchild = Delete(p->lchild, q->data);
        } else {
            q = InSucc(p->rchild);
            p->data = q->data;
            p->rchild = Delete(p->rchild, q->data);
        }
    }
    return p;
}
 
int BST::Height(Node *p) {
    int x;
    int y;
    if (p == nullptr){
        return 0;
    }
    x = Height(p->lchild);
    y = Height(p->rchild);
    return x > y ? x + 1 : y + 1;
}
 
Node* BST::InPre(Node *p) {
    while (p && p->rchild != nullptr){
        p = p->rchild;
    }
    return p;
}
 
Node* BST::InSucc(Node *p) {
    while (p && p->lchild != nullptr){
        p = p->lchild;
    }
    return p;
}
 
void BST::createFromPreorder(int *pre, int n) {
 
    // Create root node
    int i = 0;
    root = new Node;
    root->data = pre[i++];
    root->lchild = nullptr;
    root->rchild = nullptr;
 
    // Iterative steps
    Node* t;
    Node* p = root;
    stack<Node*> stk;
 
    while (i < n){
        // Left child case
        if (pre[i] < p->data){
            t = new Node;
            t->data = pre[i++];
            t->lchild = nullptr;
            t->rchild = nullptr;
            p->lchild = t;
            stk.push(p);
            p = t;
        } else {
            // Right child cases
            if (pre[i] > p->data && pre[i] < stk.empty() ? 32767 : stk.top()->data){
                t = new Node;
                t->data = pre[i++];
                t->lchild = nullptr;
                t->rchild = nullptr;
                p->rchild = t;
                p = t;
            } else {
                p = stk.top();
                stk.pop();
            }
        }
    }
}
 
 
int main() {
 
    BST bst;
 
    // Iterative insert
    bst.iInsert(10);
    bst.iInsert(5);
    bst.iInsert(20);
    bst.iInsert(8);
    bst.iInsert(30);
 
    // Inorder traversal
    bst.Inorder(bst.getRoot());
    cout << endl;
 
    // Iterative search
    Node* temp = bst.iSearch(2);
    if (temp != nullptr){
        cout << temp->data << endl;
    } else {
        cout << "Element not found" << endl;
    }
 
    // Recursive search
    temp = bst.rSearch(bst.getRoot(), 20);
    if (temp != nullptr){
        cout << temp->data << endl;
    } else {
        cout << "Element not found" << endl;
    }
 
    // Recursive insert
    bst.rInsert(bst.getRoot(), 50);
    bst.rInsert(bst.getRoot(), 70);
    bst.rInsert(bst.getRoot(), 1);
    bst.Inorder(bst.getRoot());
    cout << "\n" << endl;
 
    // Inorder predecessor and inorder successor
    BST bs;
    bs.iInsert(5);
    bs.iInsert(2);
    bs.iInsert(8);
    bs.iInsert(7);
    bs.iInsert(9);
    bs.iInsert(1);
 
    temp = bs.InPre(bs.getRoot());
    cout << "InPre: " << temp->data << endl;
 
    temp = bs.InSucc(bs.getRoot());
    cout << "InSucc: " << temp->data << endl;
 
    bs.Inorder(bs.getRoot());
    cout << endl;
 
    // Delete
    bs.Delete(bs.getRoot(), 5);
    bs.Inorder(bs.getRoot());
    cout << endl;
 
    // BST from Preorder traversal
    cout << "BST from Preorder: " << flush;
    int pre[] = {30, 20, 10, 15, 25, 40, 50, 45};
    int n = sizeof(pre)/sizeof(pre[0]);
 
    BST b;
    b.createFromPreorder(pre, n);
    b.Inorder(b.getRoot());
    cout << endl;
 
    return 0;
}

----------------------
Main part :- 


void BST::createFromPreorder(int *pre, int n) {
 
    // Create root node
    int i = 0;
    root = new Node;
    root->data = pre[i++];
    root->lchild = nullptr;
    root->rchild = nullptr;
 
    // Iterative steps
    Node* t;
    Node* p = root;
    stack<Node*> stk;
 
    while (i < n){
        // Left child case
        if (pre[i] < p->data){
            t = new Node;
            t->data = pre[i++];
            t->lchild = nullptr;
            t->rchild = nullptr;
            p->lchild = t;
            stk.push(p);
            p = t;
        } else {
            // Right child cases
            if (pre[i] > p->data && pre[i] < stk.empty() ? 32767 : stk.top()->data){
                t = new Node;
                t->data = pre[i++];
                t->lchild = nullptr;
                t->rchild = nullptr;
                p->rchild = t;
                p = t;
            } else {
                p = stk.top();
                stk.pop();
            }
        }
    }
}

----------------------------------------------------------------------
29.)     < incomplete >




----------------------------------------------------------------------
----------------------------------------------------------------------
                    < AVL  TREE >

30.)     < AVL Tree ( height Balance wala ) , LL, RR, LR, RL Rotation and Insert >


#include <iostream>
using namespace std;

class Node
{
    public:
        Node* lchild;
        int data;
        Node* rchild;
        int height;
};

class AVL
{
    public:
        Node* root;
        
        AVL(){ root = nullptr; }
        
        // Helper methods for inserting
        int NodeHeight(Node* p);
        int BalanceFactor(Node* p);
        Node* LLRotation(Node* p);
        Node* RRRotation(Node* p);
        Node* LRRotation(Node* p);
        Node* RLRotation(Node* p);
        
        // insert
        Node* rInsert(Node* p,int key);
        
        // Traversal
        void Inorder(Node* p);
        void Inorder(){ Inorder(root); }
        Node* getRoot(){return root; }
        
};

int AVL::NodeHeight(Node* p)
{
    int hl;
    int hr;
    
    hl = (p and p->lchild) ? p->lchild->height : 0;
    hr = (p and p->rchild) ? p->rchild->height : 0;
    
    return hl>hr ? hl+1: hr+1;
}

int AVL::BalanceFactor(Node* p)
{
    int hl;
    int hr;
    
    hl = (p and p->lchild) ? p->lchild->height : 0;
    hr = (p and p->rchild) ? p->rchild->height : 0;
    
    return hl-hr;
}

Node* AVL::LLRotation(Node* p)
{
    Node* pl = p->lchild;
    Node*plr = pl->rchild;
    
    pl->rchild = p;
    p->lchild = plr;
    
    // Update height
    p->height = NodeHeight(p);
    pl->height = NodeHeight(pl);
    
    // Update root
    if(root == p)
    {
        root = pl;
    }
    
    return pl;
}

Node* AVL::RRRotation(Node* p)
{
    Node* pr = p->rchild;
    Node* prl = pr->lchild;
    
    pr->lchild = p;
    p->rchild = prl;
    
    // Update height
    pr->height = NodeHeight(pr);
    p->height = NodeHeight(p);
    
    // Update root
    if(root == p)
    {
        root = pr;
    }
    return pr;
}

Node* AVL::LRRotation(Node* p)
{
    Node* pl  = p->lchild;
    Node* plr = pl->rchild;
    
    pl->rchild = plr->lchild;
    p->lchild = plr->rchild;
    plr->lchild = pl;
    
    plr->rchild = p;
    
    // Update height
    pl->height = NodeHeight(pl);
    p->height = NodeHeight(p);
    plr->height = NodeHeight(plr);
    
    // Update root
    if(p == root)
    {
        root = plr;
    }
    return plr;
}

Node* AVL::RLRotation(Node* p)
{
    Node* pr = p->rchild;
    Node* prl = pr->lchild;
    
    pr->lchild = prl->rchild;
    p->rchild = prl->lchild;
    prl->lchild = p;
    prl->rchild = pr;
    
    // Update height
    pr->height  =  NodeHeight(pr);
    p->height   =  NodeHeight(p);
    prl->height =  NodeHeight(prl);
    
    // Update root
    if(root == p)
    {
        root = prl;
    }
    return prl;
}

Node* AVL::rInsert(Node *p,int key)
{
    Node* t;
    if(p == nullptr)
    {
        t = new Node;
        t->lchild = nullptr;
        t->data = key;
        t->rchild = nullptr;
        t->height = 1;  // Starting height from 1 onwards instead of 0
        return t;
    }
    
    if(key < p->data)
    {
        p->lchild = rInsert(p->lchild, key);
    }
    else if(key > p->data)
    {
        p->rchild = rInsert(p->rchild, key);
    }
    
    // Update height
    p->height = NodeHeight(p);
    
    // Balance Factor and Rotation
    
    if(BalanceFactor(p) == 2 && BalanceFactor(p->lchild) == 1)
    {
        return LLRotation(p);
    }
    else if(BalanceFactor(p) == 2 && BalanceFactor(p->lchild) == -1)
    {
        return LRRotation(p);
    }
    else if(BalanceFactor(p) == -2 && BalanceFactor(p->rchild) == -1)
    {
        return RRRotation(p);
    }
    else if(BalanceFactor(p) == -2 && BalanceFactor(p->rchild) == 1)
    {
        return RLRotation(p);
    }
    return p;
}

void AVL::Inorder(Node* p)
{
    if(p)
    {
        Inorder(p->lchild);
        cout<<p->data<<", "<<flush;
        Inorder(p->rchild);
    }
}

int main()
{
    // LR Rotation
    AVL tlr;
    tlr.root = tlr.rInsert(tlr.root, 50);
    tlr.root = tlr.rInsert(tlr.root, 40);
    
    tlr.Inorder();
    cout << endl;
    cout << tlr.root->data << endl;
 
    // RL Rotation
    AVL trl;
    trl.root = trl.rInsert(trl.root, 20);
    trl.root = trl.rInsert(trl.root, 50);
    trl.root = trl.rInsert(trl.root, 30);
 
 
    trl.Inorder();
    cout << endl;
    cout << trl.root->data << endl;
    
    
    return 0;
}

-----------------------------------------------------------------------
31.)       < Delete function in AVL Tree >






-----------------------------------------------------------------------
-----------------------------------------------------------------------
            <   SECTION :-  HEAP  >

32.)        < Insertion in heap >

#include <iostream>
#include <vector>
using namespace std;

void Inserts(int A[],int n)
{
    int i = n;
    int val = A[9];
    
    while(i>0 && val > A[ i%2 == 0 ? i/2-1 : i/2 ])
    {
        A[i] = A[i%2 == 0 ? i/2 -1 : i/2];
        i  = i%2 == 0 ? i/2 -1 : i/2;
    }
        A[i] = val;
}

template <class T>
void Print(T& var,int n)
{
    cout<<"A :- [";
    for(int i=0; i<n; i++)
    {
        cout<<var[i]<<flush;
        if(i<n-1)
        {
            cout<<", ";
        }
    }
    cout<<"]"<<endl;
}

void Insert2(vector<int>& vec, int key)
{
    auto i = vec.size();
    vec.emplace_back(key);
    while(i>0 && key > vec[i%2 == 0 ? i/2 - 1 : i/2])
    {
        swap(vec[i],vec[i%2 == 0 ? i/2-1 : i/2]);
        i = i%2 == 0 ? i/2 -1 : i/2;
    }
}

int main()
{
    int A[] = {45, 35, 15, 30, 10, 12, 6, 5, 20, 50};
    int size = sizeof(A)/sizeof(A[0])-1;
    Inserts(A, size);
    Print(A, size+1);
    
    vector<int> B = {45, 35, 15, 30, 10, 12, 6, 5, 20};
    cout<<"\nEnter a key\n";
    int key;
    cin>>key;
    Insert2(B, key);
    Print(B, B.size());
    
    return 0;
}

-----------------------------------------------------------------------
33.)       <  Create Heap using Array and vector  >

#include <iostream>
#include <vector>
using namespace std;

template<class T>
void Print(T& vec,char c,int size)
{
    cout<<c<<" : [";
    for(int i=0; i<size; i++)
    {
        cout<<vec[i]<<flush;
        if(i<size-1)
        {
            cout<<", ";
        }
    }
    cout<<"]";
}

void InsertInplace(int A[], int n){
    int i = n;
    int temp = A[n];
    while (i > 0 && temp > A[i % 2 == 0 ? (i/2)-1 : i/2]){
        A[i] = A[i % 2 == 0 ? (i/2)-1 : i/2];
        i = i % 2 == 0 ? (i/2)-1 : i/2;
    }
    A[i] = temp;
}

void Insert2(vector<int>& A, int n){
    auto i = A.size();
    A.emplace_back(n);
    while (i > 0 && n> A[i % 2 == 0 ? (i/2)-1 : i/2]){
        A[i] = A[i % 2 == 0 ? (i/2)-1 : i/2];
        i = i % 2 == 0 ? (i/2)-1 : i/2;
    }
    A[i] = n;
}

void createHeap(int A[],int s)
{
    for(int i=0; i<s; i++)
    {
        InsertInplace(A,i);
    }
}

void CreateHeap(int A[], int s, vector<int>& A2)
{
    for(int i=0; i<s; i++)
    {
        Insert2(A2,A[i]);
    }
}

int main()
{
    cout<<"Create Heap"<<endl;
    int b[] = {10,20,30,25,5,40,35};
    int size = sizeof(b)/sizeof(b[0]);
    Print(b, 'b',size);
    
    cout<<"\n\nInplace Insert\n";
    createHeap(b,size);
    Print(b, 'b',size);
    
    vector<int> A;
    cout<<"\n\nInsert way 2\n";
    CreateHeap(b, size, A);
    Print(A, 'A',A.size());
    
}

----------------------------------------------------------------------
34.)            <  Heap sorting ( technique 1 (plz try another method) ) >


#include <iostream>
using namespace std;


void Insert(int A[],int n) 
{ 
    int i=n,temp; 
    temp=A[i]; 
    
 while(i>1 && temp>A[i/2]) 
 { 
    A[i]=A[i/2]; 
    i=i/2; 
 } 
    A[i]=temp;
}


int Delete(int A[] , int n) // 7 
{ 
    int i,j,x,temp,val;
  
    val = A[1]; 
    x = A[n];
    A[1] = A[n]; 
    A[n] = val;
    
    i=1;j = i*2; 
    
while(j <= n-1)
{ 
    if(j < n-1 && A[j+1] > A[j])
    j = j+1;
    if(A[i] < A[j])
{    
    temp = A[i];
    A[i] = A[j];
    A[j] = temp;
    i = j;
    j = 2*j;
} 
    else
    break; 
}
 
return val; 
} 


int main() { 
    
    int H[] = {0,14,15,5,20,30,8,40}; 
    int i; 
    
    for(i=2;i<=7;i++) {
    Insert(H,i); 
    }
    
    for(i=7;i>1;i--)
    {
        Delete(H,i);
    }
    
    for(i=1;i<=7;i++) 
    cout<<H[i]<<" "; 
    cout<<endl; 
 
 return 0; 
}

------------------------------------------------------------------------
35.)      <    >



















----------------------------------------------------------------------
----------------------------------------------------------------------

1.)   < Hash Function using Linked list (Insert,search) >

#include <iostream>
using namespace std;

// Linked List node

class Node
{
    public: 
        int data;
        Node* next;
};

// Hash table
class HashTable
{
    public:
        Node** HT;
        HashTable();
        int hash(int key);
        void Insert(int key);
        int Search(int key);
        ~HashTable();
};

HashTable::HashTable()
{
    HT = new Node* [10];
    for(int i = 0; i<10; i++)
    {
        HT[i] = nullptr;
    }
}

int HashTable::hash(int key)
{
    return key % 10;
}

void HashTable::Insert(int key)
{
    int hIdx = hash(key);
    Node* t = new Node;
    t->data = key;
    t->next = nullptr;
    
    // Case: No nodes in the linked List
    if(HT[hIdx] == nullptr)
    {
        HT[hIdx] = t;
    }
    else
    {
        Node* p = HT[hIdx];
        Node* q = HT[hIdx];
        
        // Traverse to find insert position
        while(p && p->data < key)
        {
            q = p;
            p = p->next;
        }
        
        //  Case: insert position is first
        
        if(q == HT[hIdx])
        {
            t->next = HT[hIdx];
            HT[hIdx] = t;
        }
        else
        {
            t->next = q->next;
            q->next = t;
        }
    }
}

int HashTable::Search(int key)
{
    int hIdx = hash(key);
    Node* p = HT[hIdx];
    while(p)
    {
        if(p->data == key)
        {
            return p->data;
        }
        p = p->next;
    }
    return -1;
}

HashTable::~HashTable()
{
    for(int i=0; i<10; i++)
    {
        Node* p = HT[i];
        while(HT[i])
        {
            HT[i] = HT[i]->next;
            delete p;
            p = HT[i];
        }
    }
    delete []HT;
}

int main()
{
    int A[] = {16, 12, 25, 39, 6, 122, 5, 68, 75};
    int n = sizeof(A)/sizeof(A[0]);
    HashTable H;
    for(int i=0; i<n; i++)
    {
        H.Insert(A[i]);
    }
    cout<<"Successful Searrch"<<endl;
    int key = 6;
    int value = H.Search(key);
    cout<<"Key: "<<key<<", Value: "<<value<<endl;
    
    cout<<"Unsuccessful Search"<<endl;
    key = 95;
    value = H.Search(key);
    cout<<"Key: "<<key<<", Value: "<<value<<endl;
    
    return 0;
}

-----------------------------------------------------------------------
2.)       < Hash Table Linear Probing >

#include <iostream>
using namespace std;


int probe(int H[], int key)
{
    int index = key%10;
    int i=0;
    while(H[(index+i)%10] != 0)
    {
        i++;
    }
    return (index+i)%10;
}

void Insert(int H[],int key)
{
    int index = key%10;
    
    if(H[index] == 0)
    {
        
        H[index] = key;
    }
    else
    {
        index = probe(H,key);
        H[index] = key;
    }
}

int Search(int H[], int key)
{
    int index = key%10;
    int i =-1,k=11;
    
    do
    {
       i++;
       k--;
       
    }while(H[(index+i)%10] != key && k != 0);
    if(H[(index+i)%10] == key)
    return (index+i)%10;
    return -1;
}

int main()
{
    int H[10] = {0};
    
    Insert(H,23);
    Insert(H,22);
    Insert(H,2);
    Insert(H,32);
    cout<<Search(H,32);
    
    return 0;
}

-----------------------------------------------------------------------
3.)    < Hashing Techique in Double Hashing >

#include <iostream>
#define SIZE 10
#define PRIME 7

using namespace std;
 
template <class T>
void Print(T& vec, int n, string s){
    cout << s << ": [" << flush;
    for (int i=0; i<n; i++){
        cout << vec[i] << flush;
        if (i < n-1){
            cout << ", " << flush;
        }
    }
    cout << "]" << endl;
}
 
int Hash(int key){
    return key % SIZE;
}
 
int PrimeHash(int key){
    return PRIME - (key);
}
 
int DoubleHash(int H[], int key){
    int idx = Hash(key);
    int i = 0;
    while (H[(idx + i * PrimeHash(idx)) % SIZE] != 0){
        i++;
    }
    return (idx + i * PrimeHash(idx)) % SIZE;
}
 
void Insert(int H[], int key){
    int idx = Hash(key);
 
    if (H[idx] != 0){
        idx = DoubleHash(H, key);
    }
    H[idx] = key;
}
 
int Search(int H[], int key){
    int idx = Hash(key);
    int i = 0;
    while (H[(Hash(idx) + i * PrimeHash(idx)) % SIZE] != key){
        i++;
        if (H[(Hash(idx) + i * PrimeHash(idx)) % SIZE] == 0){
            return -1;
        }
    }
    return (Hash(idx) + i * PrimeHash(idx)) % SIZE;
}
 
 
int main() {
 
    int A[] = {5, 25, 15, 35, 95};
    int n = sizeof(A)/sizeof(A[0]);
    Print(A, n, " A");
 
    // Hash Table
    int HT[10] = {0};
    for (int i=0; i<n; i++){
        Insert(HT, A[i]);
    }
    
    Print(HT, SIZE, "HT");
 
    int index = Search(HT, 25);
    cout << "key found at: " << index << endl;
 
    index = Search(HT, 35);
    cout << "key found at: " << index << endl;
 
    return 0;
}

-----------------------------------------------------------------------
4.)    < Hashing Technique using Quadratic Probing (Square) >

#include <iostream>
#define SIZE 10

using namespace std;
 
template <class T>
void Print(T& vec, int n, string s){
    cout << s << ": [" << flush;
    for (int i=0; i<n; i++){
        cout << vec[i] << flush;
        if (i < n-1){
            cout << ", " << flush;
        }
    }
    cout << "]" << endl;
}
 
int Hash(int key){
    return key % SIZE;
}
 
int QuadraticProbe(int H[], int key){
    int idx = Hash(key);
    int i = 0;
    while (H[(idx+i*i) % SIZE] != 0){
        i++;
    }
    return (idx + i*i) % SIZE;
}
 
void Insert(int H[], int key){
    int idx = Hash(key);
 
    if (H[idx] != 0){
        idx = QuadraticProbe(H, key);
    }
    H[idx] = key;
}
 
int Search(int H[], int key){
    int idx = Hash(key);
    int i = 0;
    while (H[(idx+i*i) % SIZE] != key){
        i++;
        if (H[(idx + i*i) % SIZE] == 0){
            return -1;
        }
    }
    return (idx + i*i) % SIZE;
}
 
 
int main() {
 
    int A[] = {26, 30, 45, 23, 25, 43, 74, 19, 29};
    int n = sizeof(A)/sizeof(A[0]);
    Print(A, n, " A");
 
    // Hash Table
    int HT[10] = {0};
    for (int i=0; i<n; i++){
        Insert(HT, A[i]);
    }
    Print(HT, SIZE, "HT");
 
    int index = Search(HT, 25);
    cout << "key found at: " << index << endl;
 
    index = Search(HT, 35);
    cout << "key found at: " << index << endl;
 
    return 0;
}

-----------------------------------------------------------------------
5.)    <  >


-----------------------------------------------------------------------
-----------------------------------------------------------------------
                     <  Sorting Techniques  >
1.) < Bubble Sort >

#include <iostream> 
using namespace std;

void Swap(int *A, int *B)
{
    int temp;
    temp = *A;
    *A = *B;
    *B = temp;
}

void BubbleSort(int A[],int size)
{
    for(int i=0; i<size-1; i++)
    {
        for(int j=0; j<size-1-i; j++)
        {
            if(A[j] > A[j+1])
            {
                Swap(&A[j],&A[j+1]);
            }
        }
    }
}


template <class T>
void Print(T& vec,int size,string s)
{
    cout<<s<<" :- ["<<flush;
    for(int i =0; i<size; i++)
    {
        cout<<vec[i]<<flush;
        if(i<size-1)
        {
            cout<<", ";
        }
    }
    cout<<"]";
}


int main()
{
    int A[] = {3, 7, 9, 10, 6, 5, 12, 4, 11, 2};
    int size = sizeof(A)/sizeof(A[0]);
    Print(A,size,"A");
    cout<<endl;
    BubbleSort(A,size);
    Print(A,size,"BubbleSort");
    
    return 0;
}

-----------------------------------------------------------------------
2.)    <  Insertion Sort program in c++ using Array >

#include <iostream>
using namespace std;

void InsertionSort(int A[],int size)
{
    for(int i=1; i<size; i++)
    {
        int j = i-1;
        int x = A[i];
        while(j>-1 && A[j]>x)
        {
            A[j+1] = A[j];
            j--;
        }
        A[j+1] = x;
    }
}

template <class T>
void Print(T& vec,int size,string s)
{
    cout<<s<<" :- ["<<flush;
    for(int i=0; i<size; i++)
    {
        cout<<vec[i]<<flush;
        if(i<size-1)
        {
            cout<<", ";
        }
    }
    cout<<"]"<<endl;
}

int main()
{
    int A[] = {19, 17, 15, 13, 11, 9, 7, 5, 3, 1};
    int size = sizeof(A)/sizeof(A[0]);
    Print(A,size,"A");
    
    InsertionSort(A,size);
    Print(A,size,"InsertionSort");
    
    return 0;
}

----------------
     < Insertion Sort program in c++ using Link-list >

#include <iostream>
using namespace std;

struct Node
{
    int data;
    Node* next;
};
struct Node* head;

void Insert(int val)
{
    Node* temp;
    Node* p = head;
    if(!p)
    {
        head = new Node;
        head->data = val;
        head->next == nullptr;
    }
    else
    {
        Node* h;
        while(p != nullptr)
        {
            h=p;
            int x;
            if(h->data > val)
            {
                x = h->data;
                h->data = val;
                val = x;
            }
            p = p->next;
        }
        temp = new Node;
        temp->data = val;
        temp->next = nullptr;
        h->next = temp;
    }
}

void Display(Node* p)
{
    while(p)
    {
        cout<<p->data<<" "<<flush;
        p = p->next;
    }
}

int main()
{
    // Time :- O(n);
    int A[] = {5,4,6,9,2,3,8,9};
    int size = sizeof(A)/sizeof(A[0]);
    for(int i=0; i<size; i++)
    {
        Insert(A[i]);
    }
    Display(head);
    
    return 0;
}

----------------------------------------------------------------------
3.)    <  Selection Sort  >

#include <iostream>
using namespace std;
 
template <class T>
void Print(T& vec, int n, string s){
    cout << s << ": [" << flush;
    for (int i=0; i<n; i++){
        cout << vec[i] << flush;
        if (i < n-1){
            cout << ", " << flush;
        }
    }
    cout << "]" << endl;
}
 
void swap(int* x, int* y){
    int temp = *x;
    *x = *y;
    *y = temp;
}
 
void SelectionSort(int A[], int n){
    for(int i=0; i<n; i++)
    {
        int j;
        int k;
        for(j=k=i; j<n; j++)
        {
            if(A[k] > A[j])
            {
                k = j;
            }
        }
        swap(&A[i],&A[k]);
    }
}
 
int main() {
 
    int A[] = {3, 7, 9, 10, 6, 5, 12, 4, 11, 2};
    int n = sizeof(A)/sizeof(A[0]);
    Print(A, n, "A");
 
    SelectionSort(A, n);
    Print(A, n, " Sorted A");
 
    return 0;
}

----------------------------------------------------------------------
4.)    < Sort using pivot method (Quick-Short) Time :- (nlogn) >

#include <iostream>
using namespace std;

template <class T>
void Print(T& vec, int n, string s)
{
    cout<<s<<": ["<<flush;
    for(int i=0; i<n; i++)
    {
        cout<<vec[i]<<flush;
        if(i<n-1)
        {
            cout<<", "<<flush;
        }
    }
    cout<<"]"<<endl;
}

void swap(int *A, int *B)
{
    int temp = *A;
    *A = *B;
    *B = temp;
}


int PartitionA(int A[], int low, int high)
{
    int pivot = A[low];
    int i = low;
    int j = high;
    
    do
    {
        do {i++;} while(A[i] <= pivot);
        do {j--;} while(A[j] > pivot);
        
        if(i<j)
        {
            swap(&A[i],&A[j]);
        }
    } while(i<j);
    
    swap(&A[low],&A[j]);
    
    return j;
}


void QuickSortA(int A[], int low, int high)
{
    if(low < high)
    {
        int p = PartitionA(A, low, high);
        QuickSortA(A,low,p);
        QuickSortA(A,p+1,high);
    }
}

int main()
{
    cout << "Using INT_MAX or Infinity" << endl;
    int A[] = {3, 7, 9, 10, 6, 5, 12, 4, 11, 2, 32767};
    int size = sizeof(A)/sizeof(A[0]);
    Print(A,size-1,"A");
    
    QuickSortA(A,0,size-1);
    Print(A,size-1,"Sorted Array");
    cout<<endl;
    
    return 0;
}

----------------------------------------------------------------------
5.)    < Merge two sorted Array >

#include <iostream>
using namespace std;

template <class T>
void Print(T& ver, int n, string s)
{
    cout<<s<<": ["<<flush;
    for(int i=0; i<n; i++)
    {
        cout<<ver[i]<<flush;
        if(i<n-1)
        {
            cout<<", "<<flush;
        }
    }
    cout<<"]"<<flush;
}

void Merge(int A[], int B[], int C[], int s1, int s2)
{
    int i = 0;
    int j = 0;
    int k = 0;
    
    while(i<s1 && j<s2)
    {
        if(A[i] < B[j])
        {
            C[k++] = A[i++];
        }
        else
        {
            C[k++] = B[j++];
        }
    }
    while(i<s1)
    {
        C[k++] = A[i++];
    }
    while(j<s2)
    {
        C[k++] = B[j++];
    }
}

int main()
{
    int A[] = {2, 10, 18, 20, 23};
    int sizeA = sizeof(A)/sizeof(A[0]);
    Print(A,sizeA,"A");
    cout<<endl;
    
    int B[] = {4, 9, 19, 25};
    int sizeB = sizeof(B)/sizeof(B[0]);
    Print(B,sizeB,"B");
    cout<<endl;
    
    int sizeC = sizeA + sizeB;
    int C[sizeC];
    Merge(A,B,C,sizeA,sizeB);
    cout<<"Merge: ["<<flush;
    for(int i=0; i<sizeC; i++)
    {
        cout<<C[i]<<flush;
        if(i<sizeC-1)
        {
            cout<<", "<<flush;
        }
    }
    cout<<"]"<<flush;
    
    return 0;
}

----------------------------------------------------------------------
6.)     < Merge-single >

#include <iostream>
using namespace std;
 
template <class T>
void Print(T& vec, int n, string s){
    cout << s << ": [" << flush;
    for (int i=0; i<n; i++){
        cout << vec[i] << flush;
        if (i < n-1){
            cout << ", " << flush;
        }
    }
    cout << "]" << endl;
}
 
void MergeSingle(int A[], int low, int mid, int high){
    int i = low;
    int j = mid+1;
    int k = low;
    int B[high+1];
    while (i <= mid && j <= high){
        if (A[i] < A[j]){
            B[k++] = A[i++];
        } else {
            B[k++] = A[j++];
        }
    }
    while (i <= mid){
        B[k++] = A[i++];
    }
    while (j <= high){
        B[k++] = A[j++];
    }
    for (int i=low; i<=high; i++){
        A[i] = B[i];
    }
}
 
int main() {
 
    int D[] = {2, 5, 8, 12, 3, 6, 7, 10};
    Print(D, sizeof(D)/sizeof(D[0]), "\t\tD");
    MergeSingle(D, 0, 3, 7);
    Print(D, sizeof(D)/sizeof(D[0]), " Sorted D");
 
    return 0;
}

----------------------------------------------------------------------
7.)     <  >


----------------------------------------------------------------------
8.)     <  >


----------------------------------------------------------------------
9.)     <  >


----------------------------------------------------------------------
10.)    <  >

